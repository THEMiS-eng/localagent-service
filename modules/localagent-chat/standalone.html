<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LocalAgent Chat</title>
<style>
/* ============================================================
   THEME SYSTEM - Supports both standalone dark and embedded light
   When embedded in dashboard iframe, inherits parent theme via CSS vars
   ============================================================ */

/* Default: Dark theme (standalone mode) */
:root {
    --chat-bg: #0a0a0b;
    --chat-surface: #18181b;
    --chat-surface2: #1f1f23;
    --chat-border: #27272a;
    --chat-text: #fafafa;
    --chat-text2: #a1a1aa;
    --chat-muted: #71717a;
    --chat-accent: #6366f1;
    --chat-success: #22c55e;
    --chat-error: #ef4444;
    --chat-error-bg: rgba(239,68,68,.15);
    --chat-user-bg: #1e1b4b;
    --chat-code-bg: #0d0d0f;
    --chat-voice: #ef4444;
    --chat-warning: #f59e0b;
    --chat-input-bg: #111;
    
    /* Shared with dashboard - use fallback to dashboard vars */
    --accent: var(--blue, #6366f1);
    --success: var(--success, #22c55e);
    --error: var(--error, #ef4444);
    --warning: var(--warning, #f59e0b);
}

/* Light theme (when embedded in dashboard or explicit) */
:root.light, 
body.light,
:root[data-theme="light"] {
    --chat-bg: #ffffff;
    --chat-surface: #f8f9fa;
    --chat-surface2: #f1f3f4;
    --chat-border: #e0e0e0;
    --chat-text: #202124;
    --chat-text2: #5f6368;
    --chat-muted: #9aa0a6;
    --chat-accent: #1a73e8;
    --chat-success: #34a853;
    --chat-error: #ea4335;
    --chat-error-bg: rgba(234,67,53,.1);
    --chat-user-bg: #e8f0fe;
    --chat-code-bg: #f1f3f4;
    --chat-voice: #ea4335;
    --chat-warning: #fbbc04;
    --chat-input-bg: #f8f9fa;
}

/* Auto-detect: If parent has light background, switch to light theme */
@media (prefers-color-scheme: light) {
    :root:not(.dark):not([data-theme="dark"]) {
        --chat-bg: #ffffff;
        --chat-surface: #f8f9fa;
        --chat-surface2: #f1f3f4;
        --chat-border: #e0e0e0;
        --chat-text: #202124;
        --chat-text2: #5f6368;
        --chat-muted: #9aa0a6;
        --chat-accent: #1a73e8;
        --chat-success: #34a853;
        --chat-error: #ea4335;
        --chat-error-bg: rgba(234,67,53,.1);
        --chat-user-bg: #e8f0fe;
        --chat-code-bg: #f1f3f4;
        --chat-voice: #ea4335;
        --chat-warning: #fbbc04;
        --chat-input-bg: #f8f9fa;
    }
}

/* Legacy variable mapping for backward compatibility */
:root {
    --bg: var(--chat-bg);
    --surface: var(--chat-surface);
    --surface2: var(--chat-surface2);
    --border: var(--chat-border);
    --text: var(--chat-text);
    --text2: var(--chat-text2);
    --muted: var(--chat-muted);
    --accent: var(--chat-accent);
    --success: var(--chat-success);
    --error: var(--chat-error);
    --error-bg: var(--chat-error-bg);
    --user-bg: var(--chat-user-bg);
    --code-bg: var(--chat-code-bg);
    --voice: var(--chat-voice);
    --warning: var(--chat-warning);
    --linter-good: #166534;
    --linter-warn: #854d0e;
    --linter-bad: #991b1b;
}

*{box-sizing:border-box;margin:0;padding:0}
body{font-family:system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:transparent;color:var(--chat-text);width:100%;height:100vh;overflow:hidden;font-size:14px;display:flex;flex-direction:column;position:relative}
.chat{display:flex;flex-direction:column;height:100%;width:100%;max-width:none;margin:0;position:relative}
.header{display:flex;align-items:center;justify-content:space-between;padding:14px 20px;background:var(--chat-surface);border-bottom:1px solid var(--chat-border)}
.header-title{font-weight:600;color:var(--chat-text)}
.header-badge{font-size:10px;padding:3px 8px;background:var(--chat-muted);color:#fff;border-radius:10px;font-weight:500}
.header-badge.ready{background:var(--chat-success)}
.header-badge.loading{background:var(--chat-warning)}
.header-badge.recording{background:var(--chat-voice)}
.header-badge.processing{background:var(--chat-accent)}
.messages{flex:1;overflow-y:auto;padding:20px;display:flex;flex-direction:column;gap:18px}
.messages:not(:has(*)){display:none;padding:0}
.messages::-webkit-scrollbar{width:6px}.messages::-webkit-scrollbar-thumb{background:var(--chat-border);border-radius:3px}
.empty{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;color:var(--chat-muted);text-align:center;gap:10px;overflow:hidden}
.empty svg{max-width:90vw;max-height:60vh}
.empty h2{color:var(--chat-text);font-size:16px}
.empty .center-post{animation:svg-rise 1.5s ease-out both;transform-origin:bottom}
.empty .balance-beam{animation:svg-stabilize 2s ease-out .5s both;transform-origin:center}
.empty .left-scale{animation:svg-settle-l 2.5s ease-out 1s both;transform-origin:center}
.empty .right-scale{animation:svg-settle-r 2.5s ease-out 1.2s both;transform-origin:center}
.empty svg text{animation:svg-fade 1s ease-out 2s both;opacity:0}
@keyframes svg-rise{from{transform:scaleY(0)}to{transform:scaleY(1)}}
@keyframes svg-stabilize{0%{transform:rotate(-15deg);opacity:0}60%{transform:rotate(5deg)}80%{transform:rotate(-2deg)}100%{transform:rotate(0);opacity:1}}
@keyframes svg-settle-l{0%{transform:translateY(-20px) rotate(-30deg);opacity:0}50%{transform:translateY(5px) rotate(10deg)}80%{transform:translateY(-2px) rotate(-5deg)}100%{transform:translateY(0) rotate(0);opacity:1}}
@keyframes svg-settle-r{0%{transform:translateY(-15px) rotate(25deg);opacity:0}50%{transform:translateY(8px) rotate(-8deg)}80%{transform:translateY(-1px) rotate(3deg)}100%{transform:translateY(0) rotate(0);opacity:1}}
@keyframes svg-fade{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
.msg{display:flex;flex-direction:column;gap:8px;max-width:82%;animation:fadeIn .2s}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}
.msg.user{align-self:flex-end}.msg.assistant{align-self:flex-start}
.bubble{padding:12px 16px;border-radius:12px;line-height:1.55}
.msg.user .bubble{background:var(--chat-user-bg);border:1px solid var(--chat-accent);border-bottom-right-radius:4px}
.msg.assistant .bubble{background:var(--chat-surface);border:1px solid var(--chat-border);border-bottom-left-radius:4px}
.content{white-space:pre-wrap;word-break:break-word;color:var(--chat-text)}
.cursor{display:inline-block;width:2px;height:1em;background:var(--chat-accent);margin-left:2px;animation:pulse 1s infinite}
@keyframes pulse{50%{opacity:.3}}
code{background:var(--chat-code-bg);padding:2px 5px;border-radius:4px;font-size:13px;font-family:'SF Mono',Consolas,monospace;color:var(--chat-text)}
.code-block{margin:10px 0;background:var(--chat-code-bg);border:1px solid var(--chat-border);border-radius:8px;overflow:hidden}
.code-block header{display:flex;justify-content:space-between;padding:6px 10px;background:var(--chat-surface);border-bottom:1px solid var(--chat-border);font-size:11px;color:var(--chat-muted)}
.code-block pre{padding:12px;margin:0;font-size:12px;overflow-x:auto;font-family:'SF Mono',Consolas,monospace;line-height:1.5;color:var(--chat-text)}
.code-block button{background:none;border:none;color:var(--chat-muted);cursor:pointer;font-size:11px}

.steps-container{background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:10px;overflow:hidden}
.steps-header{display:flex;align-items:center;gap:8px;padding:10px 14px;cursor:pointer;font-size:13px;color:var(--chat-text2)}
.steps-header:hover{background:var(--chat-surface2)}
.steps-header svg{transition:transform .2s}
.steps-header.open svg{transform:rotate(90deg)}
.steps-header .count{color:var(--chat-muted);font-size:12px}
.steps-body{display:none;border-top:1px solid var(--chat-border)}
.steps-body.open{display:block}
.step{border-bottom:1px solid var(--chat-border)}
.step:last-child{border-bottom:none}
.step-header{display:flex;align-items:center;gap:10px;padding:10px 14px;cursor:pointer;font-size:13px}
.step-header:hover{background:var(--chat-surface2)}
.step-icon{width:20px;height:20px;display:flex;align-items:center;justify-content:center}
.step-icon.running{color:var(--chat-accent)}
.step-icon.success{color:var(--chat-success)}
.step-icon.error{color:var(--chat-error)}
.step-title{flex:1;font-weight:500;color:var(--chat-text)}
.step-time{font-size:11px;color:var(--chat-muted);font-family:'SF Mono',monospace}
.step-content{display:none;padding:0 14px 12px 44px}
.step-content.open{display:block}
.step-cmd{background:var(--chat-bg);border-radius:6px;padding:10px 12px;font-family:'SF Mono',monospace;font-size:12px;color:var(--chat-text2)}
.step-error{background:var(--chat-error-bg);border:1px solid var(--chat-error);border-radius:6px;padding:10px 12px;margin-top:8px}
.step-error-title{font-weight:600;color:var(--chat-error);margin-bottom:6px;font-size:12px}
.step-error pre{font-family:'SF Mono',monospace;font-size:11px;color:var(--chat-error);white-space:pre-wrap;margin:0}

.meta{font-size:11px;color:var(--chat-muted);margin-top:8px}
.msg-tag-btn{background:#e8eaed;border:1px dashed #9ca3af;color:#5f6368;cursor:pointer;padding:2px 8px;border-radius:8px;font-size:10px;font-weight:600;display:inline-block;margin-left:6px}
.msg-tag-btn:hover{background:#3b82f6;color:white;border-color:#3b82f6}
.msg-tags{display:flex;flex-wrap:wrap;gap:4px;margin-top:6px}
.msg-tag-pill{display:inline-flex;align-items:center;gap:3px;padding:1px 6px;border-radius:8px;font-size:9px;font-weight:500;cursor:default;line-height:1.4}
.msg-tag-pill .tag-dot{width:5px;height:5px;border-radius:50%;flex-shrink:0}
.msg-tag-pill .tag-remove{background:none;border:none;color:inherit;cursor:pointer;padding:0;margin-left:2px;font-size:11px;opacity:.5}
.msg-tag-pill .tag-remove:hover{opacity:1}
.msg-tag-picker{position:absolute;top:100%;left:0;margin-top:4px;width:160px;background:white;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.15);border:1px solid #e5e7eb;z-index:1000;padding:4px;max-height:240px;overflow:auto}
.msg-tag-picker-item{display:flex;align-items:center;gap:6px;padding:6px 10px;border-radius:4px;cursor:pointer;font-size:10px;color:#374151}
.msg-tag-picker-item:hover{background:#f3f4f6}
.msg-tag-picker-item .tag-dot{width:6px;height:6px;border-radius:50%;flex-shrink:0}
.msg-tag-picker-item.selected{font-weight:600}
.msg-tag-picker-item.selected::after{content:'‚úì';margin-left:auto;font-size:11px;color:#22c55e}
.msg.tagged>.bubble{border-left:3px solid #f59e0b}
.msg.tag-dimmed{opacity:0.15;transition:opacity .2s}
.files{display:flex;flex-wrap:wrap;gap:6px;margin-top:10px}
.file{display:flex;align-items:center;gap:6px;padding:6px 10px;background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:6px;font-size:12px}
.file-icon{color:var(--chat-accent)}
.file-name{max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--chat-text)}
.file-size{color:var(--chat-muted);font-size:10px}
.file-remove{background:none;border:none;color:var(--chat-muted);cursor:pointer;padding:2px;display:flex}
.file-remove:hover{color:var(--chat-error)}

.input-area{padding:12px 16px;background:transparent;border-top:none;position:relative;width:100%}

/* ============================================================
   COLLAPSED INPUT - fits in 64px footer
   ============================================================ */
.collapsed-input{
    display:flex;
    align-items:center;
    padding:8px 16px;
    height:64px;
    width:100%;
    flex-shrink:0;
    margin-top:auto;
}
.collapsed-input .input-box-mini{
    flex:1;
    display:flex;
    align-items:center;
    gap:8px;
    background:var(--chat-surface);
    border:1px solid var(--chat-border);
    border-radius:12px;
    padding:6px 8px 6px 14px;
    width:100%;
}
.collapsed-input .input-box-mini:focus-within{
    border-color:var(--chat-accent);
    box-shadow:0 0 0 2px rgba(99,102,241,.12);
}
.collapsed-input .input-box-mini input{
    flex:1;
    border:none;
    background:none;
    outline:none;
    font-size:14px;
    color:var(--chat-text);
}
.collapsed-input .input-box-mini input::placeholder{color:var(--chat-muted)}
.collapsed-input.hidden{visibility:hidden}

/* ============================================================
   EXPANDED OVERLAY - covers footer, overlays body
   ============================================================ */
.expanded-overlay{
    display:none;
    position:absolute;
    bottom:0;
    left:0;
    right:0;
    background:var(--chat-bg);
    border-top:1px solid var(--chat-border);
    z-index:50;
    width:100%;
}
.expanded-overlay.visible{display:block}
.input-files{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:10px}

/* ============================================================
   PROMPT LINTER BAR - Real-time analysis
   ============================================================ */
.linter-bar{
    display:none;
    padding:10px 14px;
    margin-bottom:12px;
    border-radius:10px;
    align-items:center;
    gap:12px;
    font-size:12px;
    background:var(--chat-surface);
    border:1px solid var(--chat-border);
}
.linter-bar.visible{display:flex}
.linter-bar.good{background:rgba(34,197,94,0.1);border-color:var(--chat-success)}
.linter-bar.warn{background:rgba(245,158,11,0.1);border-color:var(--chat-warning)}
.linter-bar.bad{background:var(--chat-error-bg);border-color:var(--chat-error)}

.linter-score{
    font-weight:700;
    padding:4px 10px;
    border-radius:8px;
    font-size:13px;
    min-width:55px;
    text-align:center;
}
.linter-bar.good .linter-score{background:var(--chat-success);color:#fff}
.linter-bar.warn .linter-score{background:var(--chat-warning);color:#000}
.linter-bar.bad .linter-score{background:var(--chat-error);color:#fff}

.linter-meta{
    display:flex;
    gap:10px;
    color:var(--chat-text2);
    font-size:11px;
    flex-shrink:0;
}
.linter-meta span{
    display:flex;
    align-items:center;
    gap:3px;
    padding:3px 8px;
    background:var(--chat-surface2);
    border-radius:6px;
}

.linter-issues{
    display:flex;
    gap:6px;
    flex:1;
    overflow-x:auto;
    padding:2px 0;
}
.linter-issue{
    padding:4px 8px;
    border-radius:6px;
    font-size:11px;
    white-space:nowrap;
    font-weight:500;
}
.linter-issue.high{background:rgba(239,68,68,0.15);color:var(--chat-error)}
.linter-issue.medium{background:rgba(245,158,11,0.15);color:var(--chat-warning)}
.linter-issue.low{background:rgba(34,197,94,0.15);color:var(--chat-success)}

.linter-fix-btn{
    padding:6px 12px;
    background:linear-gradient(135deg, var(--chat-accent) 0%, #8b5cf6 100%);
    color:#fff;
    border:none;
    border-radius:6px;
    font-weight:500;
    cursor:pointer;
    font-size:11px;
    transition:all .15s;
    white-space:nowrap;
    position:relative;
    z-index:9999;
    pointer-events:auto;
}
.linter-fix-btn:hover{
    transform:translateY(-1px);
    box-shadow:0 4px 12px rgba(99,102,241,0.4);
}
.linter-optimize-btn{
    padding:6px 12px;
    background:linear-gradient(135deg, #f59e0b 0%, #ef4444 100%);
    color:#fff;
    border:none;
    border-radius:6px;
    font-weight:500;
    cursor:pointer;
    font-size:11px;
    transition:all .15s;
    white-space:nowrap;
    position:relative;
    z-index:9999;
    pointer-events:auto;
}
.linter-optimize-btn:hover{
    transform:translateY(-1px);
    box-shadow:0 4px 12px rgba(245,158,11,0.4);
}
.linter-optimize-btn:disabled{
    opacity:0.6;
    cursor:wait;
    transform:none;
}
.linter-tier-select{
    padding:3px 6px;
    font-size:10px;
    border:1px solid var(--chat-border);
    border-radius:4px;
    background:var(--chat-surface);
    color:var(--chat-text);
    cursor:pointer;
}
.linter-optimize-source{
    font-size:9px;
    color:var(--chat-muted);
    padding:2px 6px;
    background:rgba(245,158,11,0.1);
    border-radius:3px;
}

.linter-preview{
    display:none;
    padding:8px 12px;
    margin-top:8px;
    border-radius:8px;
    background:rgba(99,102,241,0.08);
    border:1px solid rgba(99,102,241,0.2);
    font-size:11px;
    max-height:120px;
    overflow-y:auto;
}
.linter-preview.visible{display:block}
.linter-preview-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:6px;
    font-weight:600;
    color:var(--chat-accent);
}
.linter-preview-diff{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px;
}
.linter-preview-col{
    padding:6px 8px;
    border-radius:6px;
    font-family:monospace;
    font-size:10px;
    line-height:1.4;
    white-space:pre-wrap;
    word-break:break-word;
}
.linter-preview-col.original{
    background:rgba(239,68,68,0.1);
    border:1px solid rgba(239,68,68,0.2);
    text-decoration:line-through;
    color:var(--chat-muted);
}
.linter-preview-col.fixed{
    background:rgba(34,197,94,0.1);
    border:1px solid rgba(34,197,94,0.2);
    color:var(--chat-success);
}
.linter-preview-label{
    font-size:9px;
    font-weight:600;
    text-transform:uppercase;
    margin-bottom:4px;
    opacity:0.7;
}

.input-row{display:flex;gap:10px}
.input-box{flex:1;display:flex;flex-direction:column;background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:14px;overflow:hidden}
.input-box:focus-within{border-color:var(--chat-accent);box-shadow:0 0 0 3px rgba(99,102,241,.12)}
.input-line1{padding:12px 14px 8px}
.input-line1 textarea{width:100%;background:none;border:none;color:var(--chat-text);font:inherit;font-size:15px;resize:none;outline:none;min-height:24px;max-height:120px;line-height:1.5}
.input-line1 textarea::placeholder{color:var(--chat-muted)}
.input-line2{display:flex;align-items:center;gap:4px;padding:8px 10px;border-top:1px solid var(--chat-border);background:var(--chat-surface2);position:relative;z-index:10}

/* All buttons standardized at 32px */
.input-btn{width:32px;height:32px;border:none;background:transparent;border-radius:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--chat-muted);font-size:12px;font-weight:600;transition:all .15s}
.input-btn:hover{background:rgba(99,102,241,.1);color:var(--chat-text)}
.input-btn.active{background:var(--chat-accent);color:#fff}
.input-btn svg{width:16px;height:16px;stroke:currentColor;stroke-width:1.5;fill:none}
.input-btn.mode-btn{font-weight:700;background:var(--chat-accent);color:#fff}
.input-btn.mode-btn:hover{opacity:0.9}

.send-btn{width:32px;height:32px;background:var(--chat-accent);border:none;border-radius:8px;color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:all .15s}
.send-btn:hover:not(:disabled){opacity:0.9}
.send-btn:disabled{background:#d1d5db;cursor:not-allowed}
.send-btn.stop{background:var(--chat-error)}
.send-btn svg{width:14px;height:14px}

/* DA Popup */
.da-popup{position:fixed;bottom:80px;left:10px;width:300px;background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 -4px 24px rgba(0,0,0,.15);z-index:99999;display:none;max-height:70vh;overflow:auto;margin-bottom:8px}
body.themis-embed .da-popup{bottom:20px}
.da-popup.visible{display:block}

.input-divider{width:1px;height:20px;background:var(--chat-border);margin:0 4px}
.input-spacer{flex:1}
.input-counter{min-width:20px;height:20px;padding:0 5px;background:var(--chat-accent);color:#fff;border-radius:10px;font-size:11px;font-weight:600;display:none;align-items:center;justify-content:center}
.input-counter.visible{display:flex}
.da-section{border-bottom:1px solid var(--chat-border)}
.da-section:last-child{border-bottom:none}
.da-header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;cursor:pointer;user-select:none}
.da-header:hover{background:var(--chat-surface)}
.da-header-title{font-size:11px;font-weight:600;color:var(--chat-muted);letter-spacing:0.5px}
.da-header-add{font-size:14px;color:var(--chat-muted);width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:4px}
.da-header-add:hover{background:var(--chat-surface2)}
.da-body{display:none;padding:0 8px 8px;max-height:none;overflow-y:visible}
.da-body.open{display:block}
.da-item{display:flex;align-items:center;gap:10px;padding:10px;border-radius:8px;cursor:pointer;margin-bottom:4px}
.da-item:hover{background:var(--chat-surface)}
.da-item.active{background:rgba(99,102,241,.1)}
.da-item-icon{width:36px;height:36px;border-radius:8px;background:rgba(99,102,241,.1);display:flex;align-items:center;justify-content:center;color:var(--chat-accent);font-size:14px}
.da-item-info{flex:1;min-width:0}
.da-item-name{font-size:13px;font-weight:500;color:var(--chat-text);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.da-item-desc{font-size:11px;color:var(--chat-muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.da-item-status{font-size:8px;padding:1px 5px;border-radius:3px;background:#f0fdf4;color:#166534;font-weight:600;margin-left:auto;flex-shrink:0}
.da-item.active .da-item-icon{background:var(--chat-accent);color:#fff}
.da-empty{padding:16px;text-align:center;color:var(--chat-muted);font-size:12px}
/* Legacy support */
.attach-btn,.voice-btn{background:none;border:none;color:var(--chat-muted);cursor:pointer;padding:6px;border-radius:6px;display:flex;transition:all .15s}
.attach-btn:hover{color:var(--chat-accent);background:rgba(99,102,241,.1)}
.voice-btn:hover{color:var(--chat-voice);background:rgba(239,68,68,.1)}
.voice-btn.loading{color:var(--chat-warning)}
.voice-btn.ready{color:var(--chat-success)}
.voice-btn.recording{color:#fff;background:var(--chat-voice);animation:voicePulse 1.5s ease-in-out infinite}
.voice-btn.processing{color:var(--chat-accent)}
@keyframes voicePulse{0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,.4)}50%{box-shadow:0 0 0 8px rgba(239,68,68,0)}}
textarea{flex:1;background:none;border:none;color:var(--chat-text);font:inherit;font-size:14px;resize:none;outline:none;min-height:24px;max-height:200px;line-height:1.5}
textarea::placeholder{color:var(--chat-muted)}

.voice-status{display:none;align-items:center;gap:10px;padding:12px 14px;background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:10px;margin-bottom:12px;font-size:13px;color:var(--chat-text)}
.voice-status.active{display:flex}
.voice-status.recording{border-color:var(--chat-voice);background:rgba(239,68,68,.08)}
.voice-status.processing{border-color:var(--chat-accent);background:rgba(99,102,241,.08)}
.voice-status.loading{border-color:var(--chat-warning);background:rgba(245,158,11,.08)}
.voice-status .status-icon{display:flex}
.voice-status .status-text{flex:1;color:var(--chat-text)}
.voice-status .status-detail{font-size:11px;color:var(--chat-muted);margin-top:2px}
.voice-status .stop-btn{background:var(--chat-voice);border:none;color:#fff;cursor:pointer;font-size:12px;padding:8px 16px;border-radius:6px;font-weight:500}
.voice-status .stop-btn:hover{opacity:0.9}
.voice-status .cancel-btn{background:none;border:1px solid var(--chat-border);color:var(--chat-text2);cursor:pointer;font-size:11px;padding:6px 12px;border-radius:6px}
.voice-status .cancel-btn:hover{border-color:var(--chat-error);color:var(--chat-error)}

.waveform{display:flex;align-items:center;gap:2px;height:24px;padding:0 8px}
.waveform-bar{width:3px;background:var(--chat-voice);border-radius:2px;transition:height 0.05s}

.progress{height:6px;background:var(--chat-bg);border-radius:3px;overflow:hidden;margin-top:6px}
.progress-bar{height:100%;background:var(--chat-accent);transition:width .3s}

.drop-zone{position:fixed;inset:0;background:rgba(99,102,241,.08);border:3px dashed var(--chat-accent);display:none;flex-direction:column;align-items:center;justify-content:center;gap:12px;color:var(--chat-accent);font-size:16px;font-weight:500;z-index:100}
.drop-zone.active{display:flex}
body.themis-embed .drop-zone{display:none !important}
.scroll-btn{position:fixed;bottom:90px;right:20px;width:36px;height:36px;background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:50%;display:none;align-items:center;justify-content:center;color:var(--chat-text);cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,.15)}
.scroll-btn.visible{display:flex}

@keyframes spin{to{transform:rotate(360deg)}}
.spin{animation:spin .8s linear infinite}

/* THEMIS EMBED MODE: Hide input (parent provides unified input) */
body.themis-embed .input-area,
body.themis-embed .expanded-overlay,
body.themis-embed .collapsed-input {
    display: none !important;
}

/* File download card hover (replaces JS onmouseover/onmouseout) */
.file-download:hover { border-color: var(--chat-accent) !important; }
body.themis-embed .messages {
    padding-bottom: 16px !important;
}
</style>
<script>
// Detect THEMIS embed mode and add class
if (window.location.search.includes('mode=themis') || window.parent !== window) {
    document.addEventListener('DOMContentLoaded', function() {
        document.body.classList.add('themis-embed');
        // Remove dropzone element in THEMIS mode
        const dropZone = document.getElementById('dropZone');
        if (dropZone) dropZone.remove();
        // Notify THEMIS parent that chat iframe is ready
        if (window.parent !== window) {
            window.parent.postMessage({ type: 'chat-ready' }, '*');
            console.log('[Chat] Sent chat-ready to parent');
        }
    });

    // Listen for messages from THEMIS parent (unified input architecture)
    window.addEventListener('message', function(event) {
        // Debug: log ALL messages received
        if (event.data && event.data.type) {
            console.log('[Chat] Message received, type:', event.data.type);
        }
        if (event.data && event.data.type === 'themis-send-message') {
            const text = event.data.message;
            const attachments = event.data.attachments || [];
            console.log('[Chat] Received themis-send-message:', text?.substring(0,50), 'attachments:', attachments.length);
            if (attachments.length > 0) {
                console.log('[Chat] First attachment:', attachments[0].name, attachments[0].type, 'hasPreview:', !!attachments[0].preview);
            }
            if ((text || attachments.length > 0) && typeof window.sendFromThemis === 'function') {
                window.sendFromThemis(text, attachments);
            }
        }
        // Handle THEMIS context updates
        if (event.data && event.data.type === 'themis-context') {
            console.log('[Chat] Received themis-context:', event.data);
            // Apply theme/context if needed
            if (event.data.theme === 'dark') {
                document.documentElement.classList.remove('light');
                document.documentElement.classList.add('dark');
            } else if (event.data.theme === 'light') {
                document.documentElement.classList.remove('dark');
                document.documentElement.classList.add('light');
            }
        }
        // Handle THEMIS chat result (API called directly by THEMIS)
        if (event.data && event.data.type === 'themis-chat-result') {
            console.log('[Chat] Received themis-chat-result');
            const { userMessage, attachments, response } = event.data;
            // Display user message
            if (typeof window.addUserMsg === 'function') {
                window.addUserMsg(userMessage || '', attachments || []);
            }
            // Display assistant response
            if (typeof window.addAssistantResponse === 'function') {
                window.addAssistantResponse(response);
            } else {
                // Fallback: add response directly
                const msgs = document.getElementById('msgs');
                if (msgs) {
                    const userDiv = document.createElement('div');
                    userDiv.className = 'msg user';
                    userDiv.innerHTML = '<div class="content">' + (userMessage || '') + (attachments?.length ? ' [' + attachments.map(a=>a.name).join(', ') + ']' : '') + '</div>';
                    msgs.appendChild(userDiv);

                    const assistantDiv = document.createElement('div');
                    assistantDiv.className = 'msg assistant';
                    assistantDiv.innerHTML = '<div class="content">' + (response || 'No response') + '</div>';
                    msgs.appendChild(assistantDiv);

                    msgs.scrollTop = msgs.scrollHeight;
                }
            }
        }
        // Toggle Skills popup (from THEMIS parent)
        if (event.data && event.data.type === 'toggle-skills') {
            const btn = document.getElementById('btnDA');
            if (btn) btn.click();
        }
        // Toggle Saved Prompts (from THEMIS parent)
        if (event.data && event.data.type === 'toggle-saved-prompts') {
            const btn = document.getElementById('btnFav');
            if (btn) btn.click();
        }
        // Toggle Voice recording (from THEMIS parent)
        if (event.data && event.data.type === 'toggle-voice') {
            console.log('[CHAT] toggle-voice received');
            try {
              if (typeof window.__toggleVoice === 'function') {
                window.__toggleVoice();
              } else {
                var btn = document.getElementById('voiceBtn');
                if (btn) btn.click();
              }
            } catch(e) { console.error('[CHAT] toggle-voice error:', e); }
        }
        // Search conversation ‚Äî highlight/dim messages matching query
        if (event.data && event.data.type === 'search-conversation') {
            var query = (event.data.query || '').trim().toLowerCase();
            var msgsContainer = document.getElementById('msgs');
            if (!msgsContainer) return;
            var msgs = msgsContainer.querySelectorAll('.msg');
            console.log('[Chat] search-conversation, query="' + query + '", msgs=' + msgs.length);

            // Remove all existing highlights
            msgsContainer.querySelectorAll('mark[data-search]').forEach(function(m) {
                var parent = m.parentNode;
                parent.replaceChild(document.createTextNode(m.textContent), m);
                parent.normalize();
            });
            // Reset opacity
            msgs.forEach(function(msg) { msg.style.opacity = ''; });

            if (!query) return;

            // Highlight text nodes inside .bubble (safe: won't corrupt HTML tags)
            function highlightTextNodes(el, q) {
                var found = false;
                var walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
                var nodes = [];
                while (walker.nextNode()) nodes.push(walker.currentNode);
                nodes.forEach(function(node) {
                    var idx = node.textContent.toLowerCase().indexOf(q);
                    if (idx === -1) return;
                    found = true;
                    var parts = [];
                    var text = node.textContent;
                    var pos = 0;
                    while (idx !== -1) {
                        if (idx > pos) parts.push(document.createTextNode(text.slice(pos, idx)));
                        var mark = document.createElement('mark');
                        mark.setAttribute('data-search', '1');
                        mark.style.cssText = 'background:#fef08a;color:#000;border-radius:2px;padding:0 2px';
                        mark.textContent = text.slice(idx, idx + q.length);
                        parts.push(mark);
                        pos = idx + q.length;
                        idx = text.toLowerCase().indexOf(q, pos);
                    }
                    if (pos < text.length) parts.push(document.createTextNode(text.slice(pos)));
                    var frag = document.createDocumentFragment();
                    parts.forEach(function(p) { frag.appendChild(p); });
                    node.parentNode.replaceChild(frag, node);
                });
                return found;
            }

            var firstMatch = null;
            msgs.forEach(function(msg) {
                var bubble = msg.querySelector('.bubble');
                if (!bubble) return;
                var matched = highlightTextNodes(bubble, query);
                if (!matched) {
                    msg.style.opacity = '0.15';
                } else if (!firstMatch) {
                    firstMatch = msg;
                }
            });

            if (firstMatch) firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    });
}
</script>
</head>
<body>
<div class="chat">
<div class="messages" id="msgs"></div>
<div class="empty" id="chatLanding">
  <svg viewBox="0 0 400 400" width="600" height="600" xmlns="http://www.w3.org/2000/svg">
    <rect width="400" height="400" fill="transparent"/>
    <rect class="center-post" x="199" y="150" width="2" height="60" fill="currentColor"/>
    <rect class="balance-beam" x="130" y="189" width="140" height="2" fill="currentColor"/>
    <g class="left-scale"><line x1="160" y1="191" x2="160" y2="220" stroke="currentColor" stroke-width="1"/><rect x="145" y="220" width="30" height="2" fill="currentColor" rx="1"/></g>
    <g class="right-scale"><line x1="240" y1="191" x2="240" y2="220" stroke="currentColor" stroke-width="1"/><rect x="225" y="220" width="30" height="2" fill="currentColor" rx="1"/></g>
    <text x="200" y="280" text-anchor="middle" fill="currentColor" font-family="Inter,-apple-system,sans-serif" font-size="32" font-weight="100" letter-spacing="3px">THEMIS</text>
    <text x="200" y="310" text-anchor="middle" fill="currentColor" opacity="0.6" font-family="Inter,-apple-system,sans-serif" font-size="14" font-weight="200" letter-spacing="1.5px">EQUITABLE RESOLUTION</text>
  </svg>
  <h2>Ask about your documents</h2>
</div>
<button class="scroll-btn" id="scrollBtn"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M19 12l-7 7-7-7"/></svg></button>

<!-- EXPANDED OVERLAY - appears when typing -->
<div class="expanded-overlay" id="expandedOverlay">
<div class="input-area">
<div class="voice-status" id="voiceStatus">
<span class="status-icon" id="statusIcon"></span>
<div style="flex:1">
<div class="status-text" id="statusText">Loading...</div>
<div class="status-detail" id="statusDetail"></div>
<div class="progress" id="progressContainer" style="display:none"><div class="progress-bar" id="progressBar"></div></div>
</div>
<div class="waveform" id="waveform" style="display:none"></div>
<button class="stop-btn" id="stopBtn" style="display:none">Stop & Transcribe</button>
<button class="cancel-btn" id="cancelBtn">Cancel</button>
</div>

<!-- PROMPT LINTER BAR -->
<div class="linter-bar" id="linterBar">
    <div class="linter-score" id="linterScore">100</div>
    <div class="linter-meta">
        <span id="linterLang">üåç EN</span>
        <span id="linterTask">üéØ unknown</span>
        <span id="linterTokens">üìä ~0</span>
        <span id="linterCost">üí∞ $0.000</span>
    </div>
    <div class="linter-issues" id="linterIssues"></div>
    <button class="linter-fix-btn" id="linterFixBtn" style="display:none" onclick="window.applyFix(); return false;">‚ú® Auto-fix</button>
    <select class="linter-tier-select" id="linterTier" title="Optimization depth">
        <option value="beginner">Beginner</option>
        <option value="intermediate" selected>Intermediate</option>
        <option value="advanced">Advanced</option>
    </select>
    <button class="linter-optimize-btn" id="linterOptimizeBtn" style="display:none" onclick="window.optimizePrompt(); return false;">‚ö° Optimize</button>
</div>
<div class="linter-preview" id="linterPreview">
    <div class="linter-preview-header">
        <span>üîÑ Rewrite Preview</span>
        <span style="font-weight:400;font-size:10px;color:var(--chat-muted)">Click Auto-fix to apply</span>
    </div>
    <div class="linter-preview-diff">
        <div class="linter-preview-col original">
            <div class="linter-preview-label">Original</div>
            <div id="previewOriginal"></div>
        </div>
        <div class="linter-preview-col fixed">
            <div class="linter-preview-label">Auto-fixed</div>
            <div id="previewFixed"></div>
        </div>
    </div>
</div>

<div class="input-files" id="inputFiles"></div>
<div class="input-row">
<div class="input-box">
<div class="input-line1">
<textarea id="input" placeholder="Ask about your documents..." rows="1"></textarea>
</div>
<div class="input-line2">
<button class="input-btn mode-btn" id="btnMode" title="Toggle Search/Analysis"><strong>S</strong></button>
<button class="input-btn" id="btnDA" title="Assistants & Skills">DA</button>
<button class="input-btn" id="btnFav" title="Saved Prompts"><svg viewBox="0 0 24 24"><path d="M12 2l3 6 7 1-5 5 1 7-6-3-6 3 1-7-5-5 7-1z"/></svg></button>
<div class="input-divider"></div>
<button class="input-btn" id="btnTags" title="Tags"><svg viewBox="0 0 24 24"><path d="M4 4h6l10 10-6 6L4 10V4z"/><circle cx="8" cy="8" r="1.5"/></svg></button>
<button class="input-btn" id="attachBtn" title="Attach Files"><svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
<button class="input-btn" id="voiceBtn" title="Voice Input"><svg viewBox="0 0 24 24"><path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/><path d="M19 10v2a7 7 0 01-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/></svg></button>
<div class="input-spacer"></div>
<div class="input-counter" id="fileCounter">0</div>
<button class="send-btn" id="send" disabled><svg viewBox="0 0 24 24"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4z"/></svg></button>
</div>
</div>
</div>
</div>
</div>
<!-- END EXPANDED OVERLAY -->

<!-- DA Popup - Outside expanded-overlay so it works in embed mode -->
<div class="da-popup" id="daPopup">
<div class="da-section">
<div class="da-header" id="daAssistantsHeader"><span class="da-header-title">‚ñæ SPECIALISTS</span><span class="da-header-add">+</span></div>
<div class="da-body open" id="daAssistantsBody"><div class="da-empty">Loading skills...</div></div>
</div>
<div class="da-section">
<div class="da-header" id="daStyleHeader"><span class="da-header-title">‚ñ∏ STYLE & TONE</span><span class="da-header-add">+</span></div>
<div class="da-body" id="daStyleBody"><div class="da-empty">Coming soon</div></div>
</div>
<div class="da-section">
<div class="da-header" id="daSystemHeader"><span class="da-header-title">‚ñ∏ SYSTEM</span><span class="da-header-add">+</span></div>
<div class="da-body" id="daSystemBody"><div class="da-empty">Coming soon</div></div>
</div>
</div>

<!-- COLLAPSED INPUT - fits in 64px footer -->
<div class="collapsed-input" id="collapsedInput">
    <div class="input-box-mini">
        <input type="text" id="inputCollapsed" placeholder="Ask about your documents...">
        <button class="input-btn mode-btn" id="btnModeCollapsed"><strong>S</strong></button>
        <button class="send-btn" id="sendCollapsed" disabled><svg viewBox="0 0 24 24"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4z"/></svg></button>
    </div>
</div>

</div>
<input type="file" id="fileInput" multiple hidden accept="image/*,text/*,.pdf,.doc,.docx,.xls,.xlsx,.csv,.json,.xer,.mpp,.dwg,.tiff,.bmp,.msg,.eml,.pst,.ost,.md,.txt">
<div class="drop-zone" id="dropZone"><svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48"/></svg>Drop files here</div>

<!-- External Linter Bundle -->
<script src="./PromptLinter.bundle.js"></script>

<script>
// ===== API BASE DETECTION =====
// Handle file:// protocol - fallback to localhost
const getApiBase = () => {
  if (window.LOCALAGENT_API) return window.LOCALAGENT_API;
  const origin = window.location.origin;
  if (!origin || origin === 'null' || origin === 'file://' || origin.startsWith('file:')) {
    return 'http://localhost:9998';
  }
  return origin;
};
window.LOCALAGENT_API = getApiBase();

// ===== ERROR CAPTURE - Send to parent dashboard =====
(function setupErrorCapture() {
  const API_BASE = window.LOCALAGENT_API;
  
  // Track the last LLM response for error correction
  let lastLLMResponse = null;
  let lastUserPrompt = null;
  let lastMessageId = null;
  let lastSkillUsed = null;
  let lastCaseId = null;
  let isCorrectingError = false;
  
  // Export for use in main code
  window.setLastLLMContext = function(response, prompt, msgId, skill, caseId) {
    lastLLMResponse = response;
    lastUserPrompt = prompt;
    lastMessageId = msgId || Date.now().toString();
    lastSkillUsed = skill;
    lastCaseId = caseId;
  };
  
  function sendError(level, message) {
    // Send to parent window if in iframe
    if (window.parent !== window) {
      try {
        window.parent.postMessage({type: 'chat-error', level, message}, '*');
      } catch(e) {}
    }
    
    // Send to debug endpoint
    fetch(`${API_BASE}/api/debug/error`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        level: level,
        message: message,
        source: 'chat-module',
        timestamp: new Date().toISOString()
      })
    }).catch(() => {});
  }
  
  // Trigger error correction with Negotiator
  async function triggerErrorCorrection(errorMessage, codeContext) {
    if (isCorrectingError) {
      console.log('[Chat] Already correcting an error, skipping...');
      return;
    }
    
    if (!lastLLMResponse || !lastUserPrompt) {
      console.log('[Chat] No LLM context to correct');
      return;
    }
    
    isCorrectingError = true;
    console.log('[Chat] Triggering error correction for:', errorMessage.substring(0, 100));
    
    // Show correction UI
    const event = new CustomEvent('negotiator-correction', {
      detail: { status: 'started', error: errorMessage }
    });
    window.dispatchEvent(event);
    
    try {
      const response = await fetch(`${API_BASE}/themis/api/chat/error`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          message_id: lastMessageId,
          error_message: errorMessage,
          code_context: codeContext || '',
          original_prompt: lastUserPrompt,
          original_response: lastLLMResponse,
          case_id: lastCaseId,
          skill_used: lastSkillUsed
        })
      });
      
      const data = await response.json();
      
      if (data.success && data.response) {
        console.log('[Chat] Correction received, retry:', data.retry_count);
        
        // Dispatch correction event
        const correctionEvent = new CustomEvent('negotiator-correction', {
          detail: { 
            status: 'corrected', 
            response: data.response,
            retry_count: data.retry_count,
            error_type: data.error_type,
            protocol: data.protocol
          }
        });
        window.dispatchEvent(correctionEvent);
        
        // Update context for next potential error
        lastLLMResponse = data.response;
      } else {
        console.log('[Chat] Correction failed:', data.error);
        const failEvent = new CustomEvent('negotiator-correction', {
          detail: { status: 'failed', error: data.error }
        });
        window.dispatchEvent(failEvent);
      }
    } catch (e) {
      console.error('[Chat] Error correction request failed:', e);
    } finally {
      isCorrectingError = false;
    }
  }
  
  // Check if error is likely from LLM-generated code
  function isLLMCodeError(message, source) {
    // Errors from inline scripts or eval are likely LLM code
    if (source && (source.includes('eval') || source.includes('blob:') || source.includes('inline'))) {
      return true;
    }
    // Common LLM code errors
    const llmErrorPatterns = [
      /Unexpected token/,
      /is not defined/,
      /is not a function/,
      /Cannot read propert/,
      /SyntaxError/,
      /ReferenceError/,
      /TypeError/
    ];
    return llmErrorPatterns.some(p => p.test(message));
  }
  
  window.onerror = function(msg, src, line, col, err) {
    const errorMsg = `${msg} at ${src}:${line}:${col}`;
    sendError('error', errorMsg);
    
    // Check if this is an LLM code error that needs correction
    if (lastLLMResponse && isLLMCodeError(msg, src)) {
      triggerErrorCorrection(errorMsg, lastLLMResponse.substring(0, 1000));
    }
    
    return false;
  };
  
  window.onunhandledrejection = function(e) {
    const errorMsg = `Unhandled Promise: ${e.reason}`;
    sendError('error', errorMsg);
    
    if (lastLLMResponse && isLLMCodeError(String(e.reason), '')) {
      triggerErrorCorrection(errorMsg, lastLLMResponse.substring(0, 1000));
    }
  };
  
  // Intercept console.error
  const origError = console.error;
  console.error = function(...args) {
    origError.apply(console, args);
    const errorMsg = args.map(a => String(a)).join(' ');
    sendError('error', errorMsg);
    
    // Trigger correction for significant errors
    if (lastLLMResponse && isLLMCodeError(errorMsg, '')) {
      triggerErrorCorrection(errorMsg, lastLLMResponse.substring(0, 1000));
    }
  };
})();

// ===== THEME DETECTION =====
// Auto-detect if embedded in light-themed dashboard
(function detectTheme() {
  // Check URL parameter
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('theme') === 'light') {
    document.documentElement.classList.add('light');
    return;
  }
  if (urlParams.get('theme') === 'dark') {
    document.documentElement.classList.add('dark');
    return;
  }
  
  // Check if embedded in iframe with light parent
  try {
    if (window.parent !== window) {
      const parentBg = window.parent.document.body.style.backgroundColor ||
                       window.parent.getComputedStyle(window.parent.document.body).backgroundColor;
      if (parentBg) {
        // Parse RGB and check if it's light
        const rgb = parentBg.match(/\d+/g);
        if (rgb && rgb.length >= 3) {
          const brightness = (parseInt(rgb[0]) * 299 + parseInt(rgb[1]) * 587 + parseInt(rgb[2]) * 114) / 1000;
          if (brightness > 128) {
            document.documentElement.classList.add('light');
            return;
          }
        }
      }
    }
  } catch (e) {
    // Cross-origin iframe, can't access parent
  }
  
  // Check system preference
  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
    // System prefers light, but we default to dark for standalone
    // Only apply if explicitly requested
  }
  
  // Default: dark theme (already set in CSS)
})();

// ===== EXPOSE THEME API =====
window.LocalAgentChat = {
  setTheme: (theme) => {
    document.documentElement.classList.remove('light', 'dark');
    if (theme === 'light' || theme === 'dark') {
      document.documentElement.classList.add(theme);
    }
  },
  getTheme: () => {
    if (document.documentElement.classList.contains('light')) return 'light';
    if (document.documentElement.classList.contains('dark')) return 'dark';
    return 'auto';
  }
};

const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);
const delay = ms => new Promise(r => setTimeout(r, ms));
const esc = s => String(s).replace(/</g,'&lt;').replace(/>/g,'&gt;');
const time = () => new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});

// ===== DOM CACHE (avoid repeated queries in hot paths) =====
const DC = {};
function initDomCache() {
  DC.input = $('#input');
  DC.inputCollapsed = $('#inputCollapsed');
  DC.send = $('#send');
  DC.sendCollapsed = $('#sendCollapsed');
  DC.msgs = $('#msgs');
  DC.expandedOverlay = $('#expandedOverlay');
  DC.collapsedInput = $('#collapsedInput');
  DC.linterBar = $('#linterBar');
  DC.linterScore = $('#linterScore');
  DC.linterIssues = $('#linterIssues');
  DC.linterFixBtn = $('#linterFixBtn');
  DC.linterPreview = $('#linterPreview');
  DC.voiceStatus = $('#voiceStatus');
  DC.fileCounter = $('#fileCounter');
}
// Init after DOM ready (called at end of script)
const formatSize = b => {
  if(!b) return '0 B';
  const k=1024, s=['B','KB','MB'];
  const i = Math.floor(Math.log(b)/Math.log(k));
  return (b/Math.pow(k,i)).toFixed(1)+' '+s[i];
};

const icons = {
  chevron:'<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>',
  running:'<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spin"><path d="M21 12a9 9 0 11-6.219-8.56"/></svg>',
  success:'<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><path d="M22 4L12 14.01l-3-3"/></svg>',
  error:'<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M15 9l-6 6M9 9l6 6"/></svg>',
  mic:'<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/><path d="M19 10v2a7 7 0 01-14 0v-2"/></svg>',
  file:'<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><path d="M14 2v6h6"/></svg>'
};

// ===== STATE =====
let generating = false;
let files = [];
let whisper = null;  // WhisperTranscriber instance
let micPermissionGranted = false;
let isRecording = false;
let animationId = null;
let currentStream = null;
let recordedSamples = [];
let lastInputSource = 'text'; // 'text' or 'voice'
let audioContext = null;
let conversationHistory = []; // Store message history for context (capped at 50)
const HISTORY_MAX = 50;

// ===== MESSAGE TAGS =====
const MSG_TAG_OPTIONS = [
  { id: 'important', label: 'Important', color: '#ef4444' },
  { id: 'question',  label: 'Question',  color: '#3b82f6' },
  { id: 'action',    label: 'Action',    color: '#f97316' },
  { id: 'reference', label: 'Reference', color: '#22c55e' },
  { id: 'followup',  label: 'Follow-up', color: '#8b5cf6' },
  { id: 'note',      label: 'Note',      color: '#6b7280' }
];
let messageTags = {};
try { const s = sessionStorage.getItem('themis-msg-tags'); if (s) messageTags = JSON.parse(s); } catch(e) {}
function saveMessageTags() { try { sessionStorage.setItem('themis-msg-tags', JSON.stringify(messageTags)); } catch(e) {} }

function toggleMessageTag(msgIndex, tagId) {
  if (!messageTags[msgIndex]) messageTags[msgIndex] = [];
  const i = messageTags[msgIndex].indexOf(tagId);
  if (i >= 0) { messageTags[msgIndex].splice(i, 1); if (!messageTags[msgIndex].length) delete messageTags[msgIndex]; }
  else { messageTags[msgIndex].push(tagId); }
  saveMessageTags();
  renderMessageTags(msgIndex);
  window.parent.postMessage({ type: 'message-tags-updated', msgIndex, tags: messageTags[msgIndex] || [] }, '*');
}

function renderMessageTags(msgIndex) {
  const msgs = document.querySelectorAll('#msgs .msg');
  const el = msgs[msgIndex]; if (!el) return;
  const bubble = el.querySelector('.bubble'); if (!bubble) return;
  const tags = messageTags[msgIndex] || [];
  el.classList.toggle('tagged', tags.length > 0);
  el.classList.toggle('has-tags', tags.length > 0);
  let container = bubble.querySelector('.msg-tags');
  if (container) container.remove();
  if (!tags.length) return;
  container = document.createElement('div');
  container.className = 'msg-tags';
  tags.forEach(tagId => {
    const opt = MSG_TAG_OPTIONS.find(t => t.id === tagId);
    if (!opt) return;
    const pill = document.createElement('span');
    pill.className = 'msg-tag-pill';
    pill.style.background = opt.color + '18';
    pill.style.border = '1px solid ' + opt.color + '44';
    pill.style.color = opt.color;
    pill.innerHTML = '<span class="tag-dot" style="background:' + opt.color + '"></span>' + esc(opt.label) + '<button class="tag-remove" title="Remove">&times;</button>';
    pill.querySelector('.tag-remove').onclick = function(e) { e.stopPropagation(); toggleMessageTag(msgIndex, tagId); };
    container.appendChild(pill);
  });
  const meta = bubble.querySelector('.meta');
  if (meta) bubble.insertBefore(container, meta); else bubble.appendChild(container);
}

let _tagPickerCleanup = null; // track active picker listener for cleanup
function showTagPicker(msgIndex, anchorEl) {
  // Clean up previous picker listener if any
  if (_tagPickerCleanup) { _tagPickerCleanup(); _tagPickerCleanup = null; }
  document.querySelectorAll('.msg-tag-picker').forEach(p => p.remove());
  const picker = document.createElement('div');
  picker.className = 'msg-tag-picker';
  const currentTags = messageTags[msgIndex] || [];
  MSG_TAG_OPTIONS.forEach(opt => {
    const item = document.createElement('div');
    item.className = 'msg-tag-picker-item' + (currentTags.includes(opt.id) ? ' selected' : '');
    item.innerHTML = '<span class="tag-dot" style="background:' + opt.color + '"></span><span>' + esc(opt.label) + '</span>';
    item.onclick = function(e) { e.stopPropagation(); toggleMessageTag(msgIndex, opt.id); item.classList.toggle('selected', (messageTags[msgIndex] || []).includes(opt.id)); };
    picker.appendChild(item);
  });
  const meta = anchorEl.closest('.meta');
  if (meta) { meta.style.position = 'relative'; meta.appendChild(picker); }
  setTimeout(function() {
    function handler(e) {
      if (!picker.contains(e.target) && e.target !== anchorEl) {
        picker.remove();
        document.removeEventListener('mousedown', handler);
        _tagPickerCleanup = null;
      }
    }
    document.addEventListener('mousedown', handler);
    _tagPickerCleanup = () => { document.removeEventListener('mousedown', handler); };
  }, 0);
}

// ===== LINTER UI (uses external PromptLinter.bundle.js) =====
let lintTimer = null;
let lastLintResult = null;

function debounceLint() {
  clearTimeout(lintTimer);
  lintTimer = setTimeout(runLint, 350);
}

async function runLint() {
  const text = $('#input').value.trim();
  const bar = $('#linterBar');
  const fixBtn = $('#linterFixBtn');
  
  if (!text || text.length < 3) {
    bar.classList.remove('visible');
    $('#linterPreview').classList.remove('visible');
    var optBtn = $('#linterOptimizeBtn');
    if (optBtn) optBtn.style.display = 'none';
    return;
  }
  
  if (!window.PromptLinter) {
    console.warn('PromptLinter not loaded');
    return;
  }
  
  const result = await window.PromptLinter.lintPromptAsync(text);
  lastLintResult = result;
  
  // Update score
  $('#linterScore').textContent = result.score;
  
  // Update bar class
  bar.classList.remove('good', 'warn', 'bad');
  if (result.score >= 80) bar.classList.add('good');
  else if (result.score >= 50) bar.classList.add('warn');
  else bar.classList.add('bad');
  bar.classList.add('visible');
  
  // Update meta
  $('#linterLang').textContent = 'üåç ' + result.lang.toUpperCase();
  $('#linterTask').textContent = 'üéØ ' + (result.topRewrite ? result.topRewrite.skill : result.taskType);
  $('#linterTokens').textContent = 'üìä ~' + (result.tokens.input + result.tokens.output);
  $('#linterCost').textContent = 'üí∞ $' + result.tokens.cost;
  
  // Update issues
  $('#linterIssues').innerHTML = result.issues.map(i => 
    `<span class="linter-issue ${i.severity}" title="${i.fix}">${i.message}</span>`
  ).join('');
  
  // Show preview if there are rewrites or changes
  const preview = $('#linterPreview');
  const hasRewrites = result.rewrites && result.rewrites.length > 0;
  const hasChanges = result.optimized !== text;
  
  // Remove old skill buttons
  const oldSkillDiv = document.querySelector('.skill-rewrites');
  if (oldSkillDiv) oldSkillDiv.remove();
  
  // Always show Optimize button when there's input
  var optBtn = $('#linterOptimizeBtn');
  if (optBtn) optBtn.style.display = 'block';

  if (hasRewrites) {
    fixBtn.style.display = 'block';

    // Build rewrite preview
    let html = '<div class="skill-rewrites" style="margin-top:8px">';
    html += '<div style="font-size:10px;color:var(--chat-muted);margin-bottom:6px;font-weight:600">üí° SKILL REWRITES:</div>';
    
    for (const rw of result.rewrites) {
      const truncated = rw.template.length > 150 ? rw.template.slice(0, 150) + '...' : rw.template;
      const encodedTemplate = encodeURIComponent(rw.template);
      html += `<div class="rewrite-option" data-template="${encodedTemplate}" data-skill="${rw.skill}" style="margin:4px 0;padding:8px;background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:6px;cursor:pointer">`;
      html += `<div style="font-size:11px;font-weight:600;color:var(--chat-accent);margin-bottom:4px">${rw.skill} [${rw.patterns.join(', ')}]</div>`;
      html += `<div style="font-size:11px;color:var(--chat-text);white-space:pre-wrap;font-family:var(--chat-mono,monospace)">${truncated}</div>`;
      html += '</div>';
    }
    html += '</div>';
    
    $('#previewOriginal').textContent = text;
    $('#previewFixed').textContent = result.topRewrite.template;
    preview.querySelector('.linter-preview-diff').insertAdjacentHTML('afterend', html);
    preview.classList.add('visible');
  } else if (hasChanges) {
    fixBtn.style.display = 'block';
    $('#previewOriginal').textContent = text;
    $('#previewFixed').textContent = result.optimized;
    preview.classList.add('visible');
  } else {
    fixBtn.style.display = 'none';
    preview.classList.remove('visible');
  }
}

window.applyFix = function() {
  console.log('[Chat] applyFix called, lastLintResult:', lastLintResult);
  
  if (!lastLintResult) {
    console.error('[Chat] No lastLintResult!');
    return;
  }
  
  // Prefer topRewrite template if available, otherwise use optimized
  let newValue = null;
  
  if (lastLintResult.topRewrite && lastLintResult.topRewrite.template) {
    newValue = lastLintResult.topRewrite.template;
    console.log('[Chat] Using topRewrite template');
  } else if (lastLintResult.rewrites && lastLintResult.rewrites.length > 0) {
    newValue = lastLintResult.rewrites[0].template;
    console.log('[Chat] Using first rewrite template');
  } else if (lastLintResult.optimized) {
    newValue = lastLintResult.optimized;
    console.log('[Chat] Using optimized');
  }
  
  if (!newValue) {
    console.error('[Chat] No newValue to apply!');
    return;
  }
  
  console.log('[Chat] Applying value of length:', newValue.length);
  
  // Set the input value
  const inputEl = document.querySelector('#input');
  if (inputEl) {
    inputEl.value = newValue;
    console.log('[Chat] Set input.value');
  } else {
    console.error('[Chat] #input not found!');
  }
  
  // Hide preview
  const previewEl = document.querySelector('#linterPreview');
  if (previewEl) previewEl.classList.remove('visible');
  
  // Remove skill rewrites div
  const oldDiv = document.querySelector('.skill-rewrites');
  if (oldDiv) oldDiv.remove();
  
  // Resize
  if (typeof autoResize === 'function') autoResize();
  
  // Enable send buttons
  const sendBtn = document.querySelector('#send');
  const sendCollapsed = document.querySelector('#sendCollapsed');
  const inputCollapsed = document.querySelector('#inputCollapsed');
  
  if (sendBtn) sendBtn.disabled = false;
  if (sendCollapsed) sendCollapsed.disabled = false;
  if (inputCollapsed) inputCollapsed.value = newValue;
  
  console.log('[Chat] Send button enabled, running lint...');
  
  // Re-run lint on new content
  if (typeof runLint === 'function') runLint();
};
console.log('[Chat] window.applyFix DEFINED:', typeof window.applyFix === 'function');

// ============================================================
// ANTHROPIC PROMPT OPTIMIZER
// ============================================================

window.optimizePrompt = function() {
  var input = document.querySelector('#input');
  var text = input ? input.value.trim() : '';
  if (!text || text.length < 3) return;

  if (!window.PromptLinter || !window.PromptLinter.improvePrompt) {
    console.error('[Chat] PromptLinter.improvePrompt not available');
    return;
  }

  var tier = document.querySelector('#linterTier');
  var tierValue = tier ? tier.value : 'intermediate';

  // Run local optimizer ‚Äî instant, no network
  var result = window.PromptLinter.improvePrompt(text, lastLintResult || {}, tierValue);

  if (!result.success || !result.improved) {
    console.warn('[Chat] Optimizer returned no changes');
    return;
  }

  // Show result in preview
  var preview = document.querySelector('#linterPreview');
  document.querySelector('#previewOriginal').textContent = text;
  document.querySelector('#previewFixed').innerHTML = '';

  var fixedCol = document.querySelector('#previewFixed');

  // Source + tier badge
  var sourceLabel = document.createElement('div');
  sourceLabel.className = 'linter-optimize-source';
  sourceLabel.textContent = '\u26A1 Local \u00B7 ' + tierValue;
  fixedCol.appendChild(sourceLabel);

  // Changes summary
  if (result.changes && result.changes.length > 0) {
    var changesList = document.createElement('div');
    changesList.style.cssText = 'font-size:9px;color:var(--chat-muted);margin:4px 0;line-height:1.4';
    changesList.textContent = result.changes.join(' \u2022 ');
    fixedCol.appendChild(changesList);
  }

  // Improved text
  var textNode = document.createElement('div');
  textNode.style.cssText = 'margin-top:4px;white-space:pre-wrap;font-size:11px;font-family:var(--chat-mono,monospace)';
  textNode.textContent = result.improved;
  fixedCol.appendChild(textNode);

  // Update header
  var header = preview.querySelector('.linter-preview-header span:first-child');
  if (header) header.textContent = '\u26A1 Optimized Preview';
  var subHeader = preview.querySelector('.linter-preview-header span:last-child');
  if (subHeader) subHeader.textContent = 'Click Auto-fix to apply';

  preview.classList.add('visible');

  // Update preview label
  var fixedLabel = fixedCol.closest('.linter-preview-col');
  var labelEl = fixedLabel ? fixedLabel.querySelector('.linter-preview-label') : null;
  if (labelEl) labelEl.textContent = 'Optimized (' + tierValue + ')';

  // Store result so Auto-fix can apply it ‚Äî clear skill rewrites so optimized takes priority
  lastLintResult = lastLintResult || {};
  lastLintResult.optimized = result.improved;
  lastLintResult.topRewrite = null;
  lastLintResult.rewrites = null;
  lastLintResult._optimizeTier = tierValue;
  lastLintResult._optimizeChanges = result.changes;

  // Show Auto-fix button
  var fixBtn = document.querySelector('#linterFixBtn');
  if (fixBtn) fixBtn.style.display = 'block';

  console.log('[Chat] Prompt optimized locally, tier:', tierValue, 'changes:', result.changes.length);
};
console.log('[Chat] window.optimizePrompt DEFINED');

window.applyRewrite = function(encodedTemplate, skillName) {
  console.log('[Chat] applyRewrite called for skill:', skillName);
  
  const template = decodeURIComponent(encodedTemplate);
  console.log('[Chat] Template length:', template.length);
  
  // Set the input value
  const inputEl = document.querySelector('#input');
  if (inputEl) {
    inputEl.value = template;
  }
  
  // Hide preview
  const previewEl = document.querySelector('#linterPreview');
  if (previewEl) previewEl.classList.remove('visible');
  
  // Remove skill rewrites div
  const oldDiv = document.querySelector('.skill-rewrites');
  if (oldDiv) oldDiv.remove();
  
  // Activate the skill (async but we don't need to wait)
  if (window.PromptLinter && window.PromptLinter.activateSkill) {
    window.PromptLinter.activateSkill(skillName);
  }
  
  // Resize
  if (typeof autoResize === 'function') autoResize();
  
  // Enable send buttons
  const sendBtn = document.querySelector('#send');
  const sendCollapsed = document.querySelector('#sendCollapsed');
  const inputCollapsed = document.querySelector('#inputCollapsed');
  
  if (sendBtn) sendBtn.disabled = false;
  if (sendCollapsed) sendCollapsed.disabled = false;
  if (inputCollapsed) inputCollapsed.value = template;
  
  console.log('[Chat] Rewrite applied, running lint...');
  
  // Re-run lint
  if (typeof runLint === 'function') runLint();
};

window.applySkill = async function(skillName) {
  const success = await window.PromptLinter.activateSkill(skillName);
  if (success) {
    console.log('[Chat] Skill activated:', skillName);
    $('#linterTask').textContent = 'üéØ ' + skillName;
    const skillDiv = document.querySelector('.skill-suggestions');
    if (skillDiv) skillDiv.remove();
  }
};

// ===== UI =====
function updateUI(state, detail = '') {
  const status = $('#voiceStatus');
  const btn = $('#voiceBtn');
  const badge = $('#badge'); // May be null if header removed

  // Notify parent THEMIS of voice state change
  if (window.parent && window.parent !== window) {
    window.parent.postMessage({ type: 'voice-state', recording: state === 'recording', state: state, detail: detail }, '*');
  }

  status.className = 'voice-status';
  btn.className = 'input-btn';
  if (badge) badge.className = 'header-badge';
  
  $('#stopBtn').style.display = 'none';
  $('#waveform').style.display = 'none';
  $('#progressContainer').style.display = 'none';
  
  switch(state) {
    case 'idle':
      status.classList.remove('active');
      if (badge) badge.textContent = 'VOICE OFF';
      break;
      
    case 'loading':
      status.classList.add('active', 'loading');
      $('#statusIcon').innerHTML = icons.running;
      $('#statusText').textContent = detail || 'Loading...';
      $('#progressContainer').style.display = 'block';
      btn.classList.add('loading');
      if (badge) {
        badge.textContent = 'LOADING';
        badge.classList.add('loading');
      }
      break;
      
    case 'ready':
      status.classList.remove('active');
      btn.classList.add('ready');
      if (badge) {
        badge.textContent = 'VOICE READY';
        badge.classList.add('ready');
      }
      break;
      
    case 'recording':
      status.classList.add('active', 'recording');
      $('#statusIcon').innerHTML = icons.mic;
      $('#statusText').textContent = 'Recording...';
      $('#statusDetail').textContent = detail || 'Click "Stop" when done';
      $('#waveform').style.display = 'flex';
      $('#stopBtn').style.display = 'block';
      btn.classList.add('recording');
      if (badge) {
        badge.textContent = 'RECORDING';
        badge.classList.add('recording');
      }
      break;
      
    case 'processing':
      status.classList.add('active', 'processing');
      $('#statusIcon').innerHTML = icons.running;
      $('#statusText').textContent = 'Transcribing...';
      $('#statusDetail').textContent = detail || 'Processing locally with Whisper';
      btn.classList.add('processing');
      if (badge) {
        badge.textContent = 'PROCESSING';
        badge.classList.add('processing');
      }
      break;
      
    case 'error':
      status.classList.add('active');
      status.style.borderColor = 'var(--error)';
      $('#statusIcon').innerHTML = icons.error;
      $('#statusText').textContent = 'Error';
      $('#statusDetail').textContent = detail;
      if (badge) badge.textContent = 'ERROR';
      setTimeout(() => updateUI(whisper?.isLoaded() ? 'ready' : 'idle'), 3000);
      break;
  }
}

// ===== LOAD WHISPER MODULE =====
async function loadWhisperModule() {
  if (whisper?.isLoaded()) { console.log('[CHAT] Whisper already loaded'); return true; }

  console.log('[CHAT] loadWhisperModule: starting...');
  updateUI('loading', 'Loading Whisper module...');
  $('#statusDetail').textContent = '~250MB, cached after first load';
  $('#progressBar').style.width = '0%';

  try {
    // Load WhisperTranscriber via script tag if not already loaded
    if (!window.WhisperTranscriber) {
      console.log('[CHAT] Loading WhisperTranscriber.js script...');
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = '../whisper-module/WhisperTranscriber.js';
        script.onload = () => { console.log('[CHAT] WhisperTranscriber.js loaded'); resolve(); };
        script.onerror = (err) => { console.error('[CHAT] WhisperTranscriber.js load failed', err); reject(new Error('Failed to load WhisperTranscriber')); };
        document.head.appendChild(script);
      });
    } else {
      console.log('[CHAT] WhisperTranscriber already in window');
    }

    whisper = new window.WhisperTranscriber();
    console.log('[CHAT] WhisperTranscriber instance created, loading model...');

    await whisper.load('whisper-small', (p) => {
      if (p.progress !== null) {
        $('#progressBar').style.width = p.progress + '%';
        $('#statusDetail').textContent = p.progress + '%';
        // Send loading progress to parent
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({ type: 'voice-state', recording: false, state: 'loading', detail: 'Loading model: ' + p.progress + '%' }, '*');
        }
      }
    });

    console.log('‚úì Whisper module loaded');
    return true;
  } catch(e) {
    console.error('[CHAT] Whisper module error:', e);
    updateUI('error', e.message);
    return false;
  }
}

// ===== INIT VOICE =====
async function initVoice() {
  if (!whisper?.isLoaded() && !(await loadWhisperModule())) return false;
  micPermissionGranted = true;
  updateUI('ready');
  return true;
}

// ===== RECORDING WITH RAW SAMPLES =====
async function startRecording() {
  if (isRecording) { console.log('[CHAT] Already recording, skip'); return; }

  try {
    console.log('[CHAT] startRecording: requesting mic access...');
    updateUI('loading', 'Accessing microphone...');

    currentStream = await navigator.mediaDevices.getUserMedia({
      audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true }
    });
    console.log('[CHAT] Mic access granted');
    
    micPermissionGranted = true;
    
    audioContext = new AudioContext({ sampleRate: 16000 });
    // Resume AudioContext if suspended (programmatic click from postMessage doesn't count as user gesture)
    if (audioContext.state === 'suspended') {
      console.log('[CHAT] AudioContext suspended, resuming...');
      await audioContext.resume();
      console.log('[CHAT] AudioContext resumed, state:', audioContext.state);
    }
    const source = audioContext.createMediaStreamSource(currentStream);

    const processor = audioContext.createScriptProcessor(4096, 1, 1);
    recordedSamples = [];
    
    processor.onaudioprocess = (e) => {
      if (!isRecording) return;
      const input = e.inputBuffer.getChannelData(0);
      recordedSamples.push(new Float32Array(input));
    };
    
    source.connect(processor);
    processor.connect(audioContext.destination);
    
    window._processor = processor;
    
    isRecording = true;
    updateUI('recording');
    
    const analyser = audioContext.createAnalyser();
    source.connect(analyser);
    analyser.fftSize = 64;
    
    $('#waveform').innerHTML = Array(8).fill('<div class="waveform-bar" style="height:20%"></div>').join('');
    const bars = $('#waveform').querySelectorAll('.waveform-bar');
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    
    function updateWaveform() {
      if (!isRecording) return;
      analyser.getByteFrequencyData(dataArray);
      bars.forEach((bar, i) => {
        bar.style.height = Math.max(15, (dataArray[i*2] || 0) / 255 * 100) + '%';
      });
      animationId = requestAnimationFrame(updateWaveform);
    }
    updateWaveform();
    
    console.log('[CHAT] ‚úì Recording started, AudioContext state:', audioContext.state, 'sampleRate:', audioContext.sampleRate);
    
  } catch(e) {
    console.error('Record error:', e);
    if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
      micPermissionGranted = false;
      updateUI('error', 'Microphone access denied');
    } else {
      updateUI('error', 'Failed to record: ' + e.message);
    }
  }
}

async function stopRecording() {
  console.log('[CHAT] stopRecording called, isRecording:', isRecording, 'samples:', recordedSamples.length);
  if (!isRecording) return;

  isRecording = false;
  cancelAnimationFrame(animationId);
  currentStream?.getTracks().forEach(t => t.stop());
  window._processor?.disconnect();

  if (recordedSamples.length === 0) {
    console.log('[CHAT] No samples recorded');
    updateUI('ready');
    return;
  }

  updateUI('processing', 'Preparing audio...');

  // Merge recorded samples into single Float32Array
  const totalLength = recordedSamples.reduce((acc, arr) => acc + arr.length, 0);
  const merged = new Float32Array(totalLength);
  let offset = 0;
  for (const chunk of recordedSamples) {
    merged.set(chunk, offset);
    offset += chunk.length;
  }

  console.log(`[CHAT] Audio: ${merged.length} samples, ${(merged.length/16000).toFixed(1)}s`);

  updateUI('processing', 'Running Whisper...');

  try {
    // Use WhisperTranscriber module
    const result = await whisper.transcribe(merged);

    console.log('[CHAT] Transcription result:', result);
    
    if (result?.text) {
      const text = result.text;
      const current = $('#input').value;
      $('#input').value = current + (current ? ' ' : '') + text;
      autoResize();
      runLint();
      lastInputSource = 'voice';
      console.log(`‚úì Transcribed (${result.language || 'auto'}): ${text} [${result.duration}s]`);
      // Send transcription result to parent THEMIS
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'whisper-result', text: text, language: result.language || null, duration: result.duration || null }, '*');
      }
    } else {
      console.log('No speech detected');
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'whisper-result', text: null }, '*');
      }
    }
    
    updateUI('ready');
    
  } catch(e) {
    console.error('Transcribe error:', e);
    updateUI('error', e.message);
  }
  
  recordedSamples = [];
  audioContext?.close();
  audioContext = null;
}

function cancelRecording() {
  isRecording = false;
  recordedSamples = [];
  cancelAnimationFrame(animationId);
  currentStream?.getTracks().forEach(t => t.stop());
  window._processor?.disconnect();
  audioContext?.close();
  audioContext = null;
  updateUI(whisper?.isLoaded() ? 'ready' : 'idle');
}

// ===== VOICE TOGGLE (shared logic for button click AND postMessage) =====
async function toggleVoice() {
  console.log('[CHAT] toggleVoice called, isRecording:', isRecording, 'whisper loaded:', whisper?.isLoaded());
  // Stop if already recording
  if (isRecording) {
    console.log('[CHAT] Stopping recording...');
    stopRecording();
    return;
  }
  // Load Whisper module if needed, then start recording
  if (!whisper?.isLoaded()) {
    console.log('[CHAT] Loading Whisper module...');
    const loaded = await initVoice();
    console.log('[CHAT] Whisper loaded:', loaded);
    if (!loaded) return;
  }
  console.log('[CHAT] Starting recording...');
  startRecording();
}

// Expose for HEAD message handler
window.__toggleVoice = toggleVoice;

// Button click handler
$('#voiceBtn').onclick = toggleVoice;

$('#stopBtn').onclick = () => stopRecording();
$('#cancelBtn').onclick = () => cancelRecording();

// ===== SEARCH POSTMESSAGE DEBOUNCE =====
let searchPostTimer = null;
function debounceSearchPost(text) {
  clearTimeout(searchPostTimer);
  searchPostTimer = setTimeout(() => {
    if (appMode === 'search' && window.parent !== window) {
      window.parent.postMessage({ type: 'search-text', text: text }, '*');
    }
  }, 150);
}

// ===== OTHER HANDLERS =====
$('#input').onkeydown = e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); send(); } };
$('#input').oninput = () => {
  autoResize();
  debounceLint();
  lastInputSource = 'text';
  const val = DC.input.value;
  const empty = val.trim().length === 0;
  DC.send.disabled = empty;
  DC.inputCollapsed.value = val;
  DC.sendCollapsed.disabled = empty;
  updateExpandedState();
  debounceSearchPost(val);
};

// Collapsed input handlers
$('#inputCollapsed').oninput = () => {
  const text = DC.inputCollapsed.value;
  DC.input.value = text;
  const empty = text.trim().length === 0;
  DC.send.disabled = empty;
  DC.sendCollapsed.disabled = empty;
  if (!empty) {
    updateExpandedState();
    DC.input.focus();
    DC.input.selectionStart = DC.input.selectionEnd = text.length;
  }
  debounceLint();
  debounceSearchPost(text);
};

$('#inputCollapsed').onkeydown = e => { 
  if (e.key === 'Enter' && !e.shiftKey) { 
    e.preventDefault(); 
    send(); 
  } 
};

$('#sendCollapsed').onclick = send;
$('#btnModeCollapsed').onclick = () => {
  // Trigger same mode toggle as main button
  $('#btnMode').click();
};

// Function to update expanded state
function updateExpandedState() {
  const hasText = DC.input.value.trim().length > 0;
  if (hasText) {
    DC.expandedOverlay.classList.add('visible');
    DC.collapsedInput.classList.add('hidden');
  } else {
    DC.expandedOverlay.classList.remove('visible');
    DC.collapsedInput.classList.remove('hidden');
  }
}

$('#send').onclick = send;
$('#attachBtn').onclick = () => $('#fileInput').click();
$('#fileInput').onchange = e => { addFiles(e.target.files); e.target.value = ''; };
$('#scrollBtn').onclick = () => $('#msgs').scrollTo({ top: $('#msgs').scrollHeight, behavior: 'smooth' });

// ===== MODE TOGGLE - Button shows destination =====
// Analysis mode ‚Üí show S (to go to Search)
// Search mode ‚Üí show A (to go to Analysis)
let appMode = 'analysis';
const modeBtn = $('#btnMode');
modeBtn.innerHTML = '<strong>S</strong>';

// Sync with parent THEMIS mode on load
if (window.parent !== window) {
  try {
    const parentBody = window.parent.document.body;
    if (parentBody.classList.contains('mode-search')) {
      appMode = 'search';
      modeBtn.innerHTML = '<strong>A</strong>';
      $('#btnModeCollapsed').innerHTML = '<strong>A</strong>';
      $('#input').placeholder = 'Search documents...';
      $('#inputCollapsed').placeholder = 'Search documents...';
    }
  } catch(e) { /* cross-origin, ignore */ }
}

$('#btnMode').onclick = () => {
  appMode = appMode === 'analysis' ? 'search' : 'analysis';
  modeBtn.innerHTML = `<strong>${appMode === 'analysis' ? 'S' : 'A'}</strong>`;
  $('#btnModeCollapsed').innerHTML = `<strong>${appMode === 'analysis' ? 'S' : 'A'}</strong>`;
  const placeholder = appMode === 'analysis' ? 'Ask about your documents...' : 'Search documents...';
  $('#input').placeholder = placeholder;
  $('#inputCollapsed').placeholder = placeholder;
  
  // Notify parent THEMIS to toggle mode
  if (window.parent !== window) {
    window.parent.postMessage({ type: 'toggle-mode', mode: appMode }, '*');
  }
};

// ===== DA POPUP (Skills) =====
let daSkills = [];
let daActiveSkill = null;
const daPopup = $('#daPopup');

$('#btnDA').onclick = (e) => {
  e.stopPropagation();
  const isOpen = daPopup.classList.toggle('visible');
  if (isOpen) loadDaSkills();
};

document.addEventListener('click', (e) => {
  // Handle Auto-fix button click
  if (e.target.closest('#linterFixBtn') || e.target.closest('.linter-fix-btn')) {
    console.log('[Chat] Auto-fix clicked via delegation!');
    e.preventDefault();
    e.stopPropagation();
    window.applyFix();
    return;
  }
  
  // Handle DA popup close
  if (!e.target.closest('#daPopup') && !e.target.closest('#btnDA')) {
    daPopup.classList.remove('visible');
  }
  
  // Handle clicks on dynamically created rewrite options
  const rewriteOption = e.target.closest('.rewrite-option');
  if (rewriteOption) {
    console.log('[Chat] Rewrite option clicked via delegation!');
    e.preventDefault();
    e.stopPropagation();
    const template = rewriteOption.dataset.template;
    const skill = rewriteOption.dataset.skill;
    if (template && skill) {
      console.log('[Chat] Rewrite option clicked:', skill);
      window.applyRewrite(template, skill);
    }
  }
});

// Also attach directly to the button element
const fixBtnEl = document.getElementById('linterFixBtn');
if (fixBtnEl) {
  fixBtnEl.onclick = function(e) {
    console.log('[Chat] Auto-fix clicked via onclick!');
    e.preventDefault();
    e.stopPropagation();
    window.applyFix();
    return false;
  };
  fixBtnEl.onmousedown = function(e) {
    console.log('[Chat] Auto-fix MOUSEDOWN detected!');
  };
  console.log('[Chat] Direct onclick handler attached to #linterFixBtn');
} else {
  console.warn('[Chat] #linterFixBtn not found during init');
}

// Debug: log all clicks on document
document.addEventListener('mousedown', function(e) {
  console.log('[Chat] Document mousedown on:', e.target.tagName, e.target.id || e.target.className);
}, true);

// Section toggles
$('#daAssistantsHeader').onclick = () => {
  const body = $('#daAssistantsBody');
  const title = $('#daAssistantsHeader').querySelector('.da-header-title');
  body.classList.toggle('open');
  title.textContent = body.classList.contains('open') ? '‚ñæ SPECIALISTS' : '‚ñ∏ SPECIALISTS';
};
$('#daStyleHeader').onclick = () => {
  const body = $('#daStyleBody');
  const title = $('#daStyleHeader').querySelector('.da-header-title');
  body.classList.toggle('open');
  title.textContent = body.classList.contains('open') ? '‚ñæ STYLE & TONE' : '‚ñ∏ STYLE & TONE';
};
$('#daSystemHeader').onclick = () => {
  const body = $('#daSystemBody');
  const title = $('#daSystemHeader').querySelector('.da-header-title');
  body.classList.toggle('open');
  title.textContent = body.classList.contains('open') ? '‚ñæ SYSTEM' : '‚ñ∏ SYSTEM';
  if (body.classList.contains('open')) loadDaSystem();
};

async function loadDaSystem() {
  const body = $('#daSystemBody');
  body.innerHTML = '<div class="da-empty">Loading...</div>';
  try {
    const API = window.LOCALAGENT_API || window.location.origin || 'http://localhost:9998';
    const [settingsRes, modulesRes, llmRes] = await Promise.all([
      fetch(`${API}/themis/api/settings`).then(r => r.json()).catch(() => ({})),
      fetch(`${API}/themis/api/settings/modules`).then(r => r.json()).catch(() => []),
      fetch(`${API}/api/llm/active`).then(r => r.json()).catch(() => ({ active: null }))
    ]);
    const modules = Array.isArray(modulesRes) ? modulesRes : [];
    const rows = [];
    if (llmRes.active) rows.push({ label: 'LLM Provider', value: llmRes.active });
    if (settingsRes.theme) rows.push({ label: 'Theme', value: settingsRes.theme });
    if (settingsRes.language) rows.push({ label: 'Language', value: settingsRes.language });
    rows.push({ label: 'Auto-save', value: settingsRes.auto_save ? 'On' : 'Off' });
    modules.forEach(m => rows.push({ label: m.name, value: m.enabled ? 'Enabled' : 'Disabled' }));
    body.innerHTML = rows.map(r =>
      `<div class="da-item" style="padding:6px 10px;cursor:default">
        <div class="da-item-info">
          <div class="da-item-name">${r.label}</div>
        </div>
        <span class="da-item-status" style="font-size:11px">${r.value}</span>
      </div>`
    ).join('');
  } catch (err) {
    body.innerHTML = '<div class="da-empty">Error loading system info</div>';
    console.error('System load error:', err);
  }
}

async function loadDaSkills() {
  const body = $('#daAssistantsBody');
  body.innerHTML = '<div class="da-empty">Loading...</div>';
  
  try {
    const API = window.LOCALAGENT_API || window.location.origin || 'http://localhost:9998';
    const [availRes, activeRes] = await Promise.all([
      fetch(`${API}/api/skills`).then(r => r.json()).catch(() => ({ skills: [] })),
      fetch(`${API}/api/skills/active`).then(r => r.json()).catch(() => ({ active: [] }))
    ]);
    
    daSkills = availRes.skills || [];
    const activeNames = (activeRes.active || []).map(s => s.name);
    daActiveSkill = activeNames[0] || null;
    
    if (daSkills.length === 0) {
      body.innerHTML = '<div class="da-empty">No skills found<br><small>Add to ~/.localagent/skills/</small></div>';
      updateDaButton();
      return;
    }
    
    body.innerHTML = daSkills.map(skill => {
      const isActive = activeNames.includes(skill.name);
      const initial = (skill.name || '?').charAt(0).toUpperCase();
      return `<div class="da-item ${isActive ? 'active' : ''}" data-skill="${skill.name}" data-path="${skill.path || skill.name}">
        <div class="da-item-icon">${initial}</div>
        <div class="da-item-info">
          <div class="da-item-name">${skill.name}</div>
          <div class="da-item-desc">${skill.description || skill.domain || 'Analysis skill'}</div>
        </div>
        ${isActive ? '<span class="da-item-status">ok</span>' : ''}
      </div>`;
    }).join('');
    
    // Add click handlers
    body.querySelectorAll('.da-item').forEach(item => {
      item.onclick = () => toggleDaSkill(item.dataset.skill, item.dataset.path);
    });
    
    updateDaButton();
  } catch (err) {
    body.innerHTML = '<div class="da-empty">Error loading skills</div>';
    console.error('Skills load error:', err);
  }
}

async function toggleDaSkill(name, path) {
  const API = window.LOCALAGENT_API || window.location.origin || 'http://localhost:9998';
  const isActive = daActiveSkill === name;
  
  try {
    if (isActive) {
      await fetch(`${API}/api/skills/deactivate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ skill_name: name })
      });
      daActiveSkill = null;
    } else {
      if (daActiveSkill) {
        await fetch(`${API}/api/skills/deactivate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ skill_name: daActiveSkill })
        });
      }
      await fetch(`${API}/api/skills/activate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ skill_name: name })
      });
      daActiveSkill = name;
    }
    loadDaSkills();
  } catch (err) {
    console.error('Toggle skill error:', err);
  }
}

function updateDaButton() {
  const btn = $('#btnDA');
  if (daActiveSkill) {
    btn.classList.add('active');
    btn.title = `Active: ${daActiveSkill}`;
  } else {
    btn.classList.remove('active');
    btn.title = 'Assistants & Skills';
  }
}

// ===== FILE COUNTER =====
function updateFileCounter() {
  const counter = $('#fileCounter');
  if (files.length > 0) {
    counter.textContent = files.length;
    counter.classList.add('visible');
  } else {
    counter.classList.remove('visible');
  }
}

function autoResize() {
  const t = $('#input');
  t.style.height = 'auto';
  t.style.height = Math.min(t.scrollHeight, 200) + 'px';
}

// Disable drag/drop in THEMIS mode (THEMIS handles it)
if (!window.location.search.includes('mode=themis')) {
  document.ondragenter = e => { e.preventDefault(); $('#dropZone').classList.add('active'); };
  $('#dropZone').ondragleave = e => { e.preventDefault(); $('#dropZone').classList.remove('active'); };
  $('#dropZone').ondragover = e => e.preventDefault();
  $('#dropZone').ondrop = e => { e.preventDefault(); $('#dropZone').classList.remove('active'); addFiles(e.dataTransfer.files); };
}

$('#msgs').onscroll = () => {
  const m = $('#msgs');
  $('#scrollBtn').classList.toggle('visible', m.scrollHeight - m.scrollTop - m.clientHeight > 100);
};

// Convert file to base64 data URL
function fileToDataURL(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = () => resolve(null);
    reader.readAsDataURL(file);
  });
}

async function addFiles(fileList) {
  for (const f of [...fileList]) {
    if (f.size < 100*1024*1024) {
      // Convert ALL files to base64 so server can process docx/pdf/txt
      const preview = await fileToDataURL(f);
      files.push({
        name: f.name,
        size: f.size,
        type: f.type,
        preview: preview // base64 data URL for images
      });
    }
  }
  renderFiles();
}

function renderFiles() {
  $('#inputFiles').innerHTML = files.map((f,i) => `
    <div class="file">
      <span class="file-icon">${icons.file}</span>
      <span class="file-name" title="${f.name}">${f.name}</span>
      <span class="file-size">${formatSize(f.size)}</span>
      <button class="file-remove" data-i="${i}"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg></button>
    </div>
  `).join('');
  $$('.file-remove').forEach(b => b.onclick = () => { files.splice(b.dataset.i, 1); renderFiles(); });
  updateFileCounter();
}

// Called from THEMIS parent via postMessage (unified input architecture)
window.sendFromThemis = async function(text, attachments = []) {
  console.log('[Chat] sendFromThemis called:', text?.substring(0,50), 'attachments:', attachments.length);
  if ((!text && attachments.length === 0) || generating) return;

  // Set the input value
  $('#input').value = text || '';
  $('#inputCollapsed').value = text || '';

  // Convert THEMIS attachments to standalone format and store for display
  window.themisAttachments = attachments.map(att => ({
    name: att.name,
    size: att.size,
    type: att.type,
    preview: att.preview,
    data: att.preview // Also store as data for API compatibility
  }));
  console.log('[Chat] themisAttachments set:', window.themisAttachments.length, 'hasData:', !!window.themisAttachments[0]?.preview);

  await send();
};

async function send() {
  const text = $('#input').value.trim();
  // Include THEMIS attachments in file count check
  const themisAtts = window.themisAttachments || [];
  if ((!text && !files.length && !themisAtts.length) || generating) return;

  $('.empty')?.remove();
  generating = true;
  $('#send').classList.add('stop');
  $('#linterBar').classList.remove('visible');
  $('#linterPreview').classList.remove('visible');

  // Merge local files and THEMIS attachments
  const userFiles = [...files, ...themisAtts];
  window.themisAttachments = []; // Clear after use
  const inputSource = lastInputSource;
  lastInputSource = 'text';

  addUserMsg(text, userFiles, inputSource);
  $('#input').value = '';
  $('#inputCollapsed').value = '';
  $('#input').style.height = 'auto';
  files = [];
  renderFiles();
  updateExpandedState(); // Collapse back to single line
  
  const el = addAssistantMsg();
  const content = el.querySelector('.content');
  
  // Create steps container
  const stepsContainer = document.createElement('div');
  stepsContainer.className = 'steps-container';
  stepsContainer.innerHTML = `<div class="steps-header">${icons.chevron}<span>Processing</span><span class="count">...</span></div><div class="steps-body"></div>`;
  el.insertBefore(stepsContainer, el.firstChild);
  
  const stepsHeader = stepsContainer.querySelector('.steps-header');
  const stepsBody = stepsContainer.querySelector('.steps-body');
  const stepsCount = stepsContainer.querySelector('.count');
  stepsHeader.onclick = () => { stepsHeader.classList.toggle('open'); stepsBody.classList.toggle('open'); };
  stepsHeader.classList.add('open');
  stepsBody.classList.add('open');
  
  content.innerHTML = '<span class="cursor"></span>';
  
  try {
    // Call LocalAgent backend API - use same origin as current page
    const API_BASE = window.LOCALAGENT_API || window.location.origin || 'http://localhost:9998';

    console.log('[Chat] send() userFiles:', userFiles.length, userFiles.map(f => ({name: f.name, hasPreview: !!f.preview, hasData: !!f.data})));

    // Build attachments array with base64 data for LLM
    const attachmentsForAPI = userFiles.filter(f => f.preview || f.data || f.type).map(f => ({
      name: f.name,
      type: f.type || 'application/octet-stream',
      data: f.preview || f.data || null // base64 data URL
    }));

    console.log('[Chat] attachmentsForAPI:', attachmentsForAPI.length, attachmentsForAPI.map(a => ({name: a.name, type: a.type, hasData: !!a.data, dataLen: a.data?.length})));

    // Add user message to history (with attachment info)
    conversationHistory.push({
      role: 'user',
      content: text || (attachmentsForAPI.length ? `[Attached: ${attachmentsForAPI.map(a => a.name).join(', ')}]` : '')
    });
    if (conversationHistory.length > HISTORY_MAX) conversationHistory.splice(0, conversationHistory.length - HISTORY_MAX);

    const response = await fetch(`${API_BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        message: text,
        history: conversationHistory.slice(-10),
        source: inputSource,
        files: userFiles.map(f => f.name),
        // Include full attachment data for multimodal LLM
        attachments: attachmentsForAPI
      })
    });
    
    const data = await response.json();
    
    // Store context for error correction (Negotiator)
    const messageId = Date.now().toString();
    if (window.setLastLLMContext) {
      window.setLastLLMContext(
        data.response || '',
        text,
        messageId,
        data.skill_used || null,
        data.case_id || null
      );
    }
    
    // Display protocol steps from backend (minimal - user doesn't need to see internals)
    const protocolSteps = data.protocol || data.protocol_steps || [];
    stepsCount.textContent = `${protocolSteps.length} steps`;
    
    // Collapse by default - only expand if user clicks
    stepsHeader.classList.remove('open');
    stepsBody.classList.remove('open');
    
    for (const ps of protocolSteps) {
      const stepEl = addStep(stepsBody, ps.label || ps.step, ps.status === 'complete' ? 'success' : ps.status === 'error' ? 'error' : 'running');
      updateStep(stepEl, ps.status === 'complete' ? 'success' : ps.status === 'error' ? 'error' : 'success');
    }
    
    // Show negotiation info if retries occurred
    if (data.negotiation_attempts && data.negotiation_attempts > 1) {
      const negLabel = data.negotiation_success 
        ? `‚úÖ Response refined (${data.negotiation_attempts} iterations)` 
        : `‚ö†Ô∏è Best effort (${data.negotiation_attempts} attempts)`;
      addStep(stepsBody, negLabel, data.negotiation_success ? 'success' : 'running');
    }
    
    // Get response text
    let responseText = data.response || data.error || 'No response';
    
    // Add assistant response to history
    conversationHistory.push({
      role: 'assistant',
      content: responseText
    });
    if (conversationHistory.length > HISTORY_MAX) conversationHistory.splice(0, conversationHistory.length - HISTORY_MAX);
    
    // Handle tasks output
    if (data.tasks && data.tasks.length > 0) {
      responseText += '\n\n**Tasks executed:**\n';
      for (const task of data.tasks) {
        responseText += `- ${task.id}: ${task.type} ${task.filename || ''}\n`;
      }
    }
    
    // Render response in fast chunks (not word-by-word)
    const words = responseText.split(' ');
    const chunkSize = Math.max(8, Math.floor(words.length / 6));
    let buffer = '';
    for (let i = 0; i < words.length; i += chunkSize) {
      buffer += words.slice(i, i + chunkSize).join(' ') + ' ';
      content.innerHTML = parseContent(buffer) + '<span class="cursor"></span>';
      if (i + chunkSize < words.length) await delay(30);
    }
    content.innerHTML = parseContent(buffer.trim());
    
    // Debug: log files received
    console.log('Files received from API:', data.files);
    
    // Handle files created - add download buttons
    if (data.files && data.files.length > 0) {
      console.log('Creating file cards for', data.files.length, 'files');
      const filesDiv = document.createElement('div');
      filesDiv.className = 'files';
      filesDiv.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;margin-top:12px;padding-top:12px;border-top:1px solid var(--chat-border)';
      
      for (const file of data.files) {
        const fileUrl = `${API_BASE}${file.url}`;
        const fileCard = document.createElement('a');
        fileCard.href = fileUrl;
        fileCard.download = file.name;
        fileCard.className = 'file-download';
        fileCard.style.cssText = `
          display:flex;align-items:center;gap:8px;padding:10px 14px;
          background:var(--chat-surface);border:1px solid var(--chat-border);
          border-radius:8px;text-decoration:none;color:var(--chat-text);
          transition:all 0.2s;cursor:pointer;
        `;
        // Hover handled by CSS .file-download:hover rule
        
        const iconExt = file.type || '.txt';
        const iconColor = {
          '.py': '#3572A5', '.js': '#f1e05a', '.html': '#e34c26',
          '.css': '#563d7c', '.json': '#292929', '.md': '#083fa1'
        }[iconExt] || 'var(--chat-accent)';
        
        fileCard.innerHTML = `
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2">
            <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>
            <path d="M14 2v6h6"/>
          </svg>
          <div style="flex:1">
            <div style="font-weight:500;font-size:13px">${file.name}</div>
            <div style="font-size:11px;color:var(--chat-muted)">${formatSize(file.size || 0)}</div>
          </div>
          <div style="background:var(--chat-accent);color:white;padding:4px 10px;border-radius:6px;font-size:11px;font-weight:500">
            Download
          </div>
        `;
        
        filesDiv.appendChild(fileCard);
      }
      
      content.appendChild(filesDiv);
      
      // Notify parent dashboard to refresh outputs
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({type: 'files-created', files: data.files}, '*');
      }
    }
    
  } catch (e) {
    console.error('Chat error:', e);
    
    // Show error step
    const errorStep = addStep(stepsBody, 'Connection Error', 'error');
    updateStep(errorStep, 'error');
    stepsCount.textContent = '1 step';
    
    // Check if it's a connection error
    if (e.message.includes('Failed to fetch') || e.message.includes('NetworkError')) {
      content.innerHTML = parseContent(`‚ùå **Cannot connect to LocalAgent backend**

Make sure the LocalAgent service is running:

\`\`\`bash
cd ~/localagent_v3
python -m localagent.service.server
\`\`\`

Or start the service:
\`\`\`bash
./START_SERVICE.command
\`\`\`

Backend URL: \`${window.LOCALAGENT_API || window.location.origin || 'http://localhost:9998'}\``);
    } else {
      content.innerHTML = parseContent(`‚ùå **Error:** ${e.message}`);
    }
  }
  
  stepsHeader.classList.remove('open');
  stepsBody.classList.remove('open');
  
  generating = false;
  $('#send').classList.remove('stop');
  $('#msgs').scrollTop = $('#msgs').scrollHeight;
  
  // Return focus to input for continued conversation
  const isExpanded = $('#expandedOverlay').classList.contains('visible');
  if (isExpanded) {
    $('#input').focus();
  } else {
    $('#inputCollapsed').focus();
  }
}

function addStep(container, title, status) {
  const step = document.createElement('div');
  step.className = 'step';
  step.innerHTML = `<div class="step-header"><span class="chevron">${icons.chevron}</span><span class="step-icon ${status}">${icons[status]}</span><span class="step-title">${title}</span><span class="step-time"></span></div><div class="step-content"></div>`;
  container.appendChild(step);
  return step;
}

function updateStep(step, status, duration) {
  step.querySelector('.step-icon').className = 'step-icon ' + status;
  step.querySelector('.step-icon').innerHTML = icons[status];
  if (duration) step.querySelector('.step-time').textContent = (duration/1000).toFixed(2) + 's';
}

// ===== NEGOTIATOR CORRECTION LISTENER =====
// Listen for corrections from the error handler
(function setupNegotiatorListener() {
  let correctionBanner = null;
  
  window.addEventListener('negotiator-correction', function(e) {
    const detail = e.detail;
    
    if (detail.status === 'started') {
      // Show correction banner
      if (!correctionBanner) {
        correctionBanner = document.createElement('div');
        correctionBanner.id = 'correctionBanner';
        correctionBanner.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          padding: 12px 20px;
          background: linear-gradient(90deg, #f59e0b, #d97706);
          color: white;
          font-weight: 600;
          font-size: 13px;
          z-index: 10000;
          display: flex;
          align-items: center;
          gap: 10px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;
        document.body.appendChild(correctionBanner);
      }
      correctionBanner.innerHTML = `
        <span style="animation: pulse 1s infinite">üîÑ</span>
        <span>Negotiator: Correcting error...</span>
        <span style="opacity: 0.8; font-weight: 400; font-size: 12px;">${(detail.error || '').substring(0, 60)}...</span>
      `;
      correctionBanner.style.display = 'flex';
    }
    
    else if (detail.status === 'corrected') {
      // Update banner to success
      if (correctionBanner) {
        correctionBanner.style.background = 'linear-gradient(90deg, #10b981, #059669)';
        correctionBanner.innerHTML = `
          <span>‚úÖ</span>
          <span>Correction applied (attempt ${detail.retry_count})</span>
          <span style="opacity: 0.8; font-weight: 400; font-size: 12px;">Error type: ${detail.error_type}</span>
        `;
        
        // Hide after 3 seconds
        setTimeout(() => {
          if (correctionBanner) {
            correctionBanner.style.display = 'none';
          }
        }, 3000);
      }
      
      // Update the last message in chat with corrected response
      const msgs = document.querySelectorAll('.msg.assistant');
      if (msgs.length > 0) {
        const lastMsg = msgs[msgs.length - 1];
        const content = lastMsg.querySelector('.content');
        if (content && detail.response) {
          // Add correction indicator
          const correctionNote = document.createElement('div');
          correctionNote.style.cssText = `
            margin-top: 12px;
            padding: 10px 14px;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 8px;
            font-size: 12px;
            color: #10b981;
          `;
          correctionNote.innerHTML = `<strong>üîÑ Auto-corrected</strong> (${detail.error_type}) - Attempt ${detail.retry_count}`;
          
          // Replace content with corrected version
          content.innerHTML = parseContent(detail.response);
          content.appendChild(correctionNote);
          
          // Update steps panel if present
          const stepsContainer = lastMsg.querySelector('.steps-container');
          if (stepsContainer && detail.protocol) {
            const stepsBody = stepsContainer.querySelector('.steps-body');
            if (stepsBody) {
              // Add correction steps
              for (const ps of detail.protocol) {
                const stepEl = addStep(stepsBody, ps.label || ps.step, ps.status === 'complete' ? 'success' : ps.status === 'error' ? 'error' : 'running');
                updateStep(stepEl, ps.status === 'complete' ? 'success' : 'error');
              }
              // Expand to show correction steps
              stepsContainer.querySelector('.steps-header').classList.add('open');
              stepsBody.classList.add('open');
            }
          }
        }
      }
    }
    
    else if (detail.status === 'failed') {
      // Update banner to error
      if (correctionBanner) {
        correctionBanner.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)';
        correctionBanner.innerHTML = `
          <span>‚ùå</span>
          <span>Correction failed</span>
          <span style="opacity: 0.8; font-weight: 400; font-size: 12px;">${detail.error || 'Max retries exceeded'}</span>
        `;
        
        // Hide after 5 seconds
        setTimeout(() => {
          if (correctionBanner) {
            correctionBanner.style.display = 'none';
          }
        }, 5000);
      }
    }
  });
  
  // Add pulse animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  `;
  document.head.appendChild(style);
})();

function hideChatLanding() {
  const l = document.getElementById('chatLanding');
  if (l) l.style.display = 'none';
}

function addUserMsg(text, userFiles, inputSource = 'text') {
  hideChatLanding();
  const el = document.createElement('div');
  el.className = 'msg user';

  // Build files HTML with image previews (Vercel pattern)
  let filesHtml = '';
  if (userFiles.length) {
    filesHtml = '<div class="files" style="display:flex;flex-wrap:wrap;gap:8px;margin-top:8px">' +
      userFiles.map(f => {
        if (f.preview || (f.type && f.type.startsWith('image/'))) {
          // Image with preview
          const src = f.preview || (f instanceof File ? URL.createObjectURL(f) : '');
          return `<div class="file" style="display:flex;flex-direction:column;gap:4px;padding:4px;background:var(--chat-surface);border-radius:8px;border:1px solid var(--chat-border)">
            <img src="${src}" alt="${esc(f.name)}" style="width:80px;height:80px;object-fit:cover;border-radius:4px"/>
            <span class="file-name" style="font-size:10px;max-width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(f.name)}</span>
          </div>`;
        } else {
          // Regular file
          return `<div class="file"><span class="file-icon">${icons.file}</span><span class="file-name">${esc(f.name)}</span></div>`;
        }
      }).join('') + '</div>';
  }

  const sourceIcon = inputSource === 'voice' ? ' üé§' : '';
  el.innerHTML = `<div class="bubble"><div class="content">${text ? esc(text) : '<em style="color:var(--chat-muted)">(attachments only)</em>'}</div>${filesHtml}<div class="meta">${time()}${sourceIcon}<button class="msg-tag-btn" title="Add tag">+</button></div></div>`;
  $('#msgs').appendChild(el);
  const msgIndex = document.querySelectorAll('#msgs .msg').length - 1;
  el.querySelector('.msg-tag-btn').onclick = function(e) { e.stopPropagation(); showTagPicker(msgIndex, el.querySelector('.msg-tag-btn')); };
  renderMessageTags(msgIndex);
  $('#msgs').scrollTop = $('#msgs').scrollHeight;
}

function addAssistantMsg() {
  const el = document.createElement('div');
  el.className = 'msg assistant';
  el.innerHTML = `<div class="bubble"><div class="content"><span class="cursor"></span></div><div class="meta">${time()}<button class="msg-tag-btn" title="Add tag">+</button></div></div>`;
  $('#msgs').appendChild(el);
  const msgIndex = document.querySelectorAll('#msgs .msg').length - 1;
  el.querySelector('.msg-tag-btn').onclick = function(e) { e.stopPropagation(); showTagPicker(msgIndex, el.querySelector('.msg-tag-btn')); };
  renderMessageTags(msgIndex);
  return el;
}

function parseContent(s) {
  s = s.replace(/```(\w+)?\n([\s\S]*?)```/g, (_, l, c) => `<div class="code-block"><header><span>${l||'code'}</span></header><pre>${esc(c)}</pre></div>`);
  s = s.replace(/`([^`]+)`/g, '<code>$1</code>');
  s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  return s;
}

// Initialize skill on load
(async function() {
  if (window.PromptLinter && window.PromptLinter.loadActiveSkill) {
    const skill = await window.PromptLinter.loadActiveSkill();
    if (skill) {
      console.log('[Chat] Active skill:', skill.name);
      $('#linterTask').textContent = 'üéØ ' + skill.name;
    }
  }
})();

// ===== POSTMESSAGE HANDLERS (from parent) =====
window.addEventListener('message', function(event) {
  if (!event.data || !event.data.type) return;
  if (event.data.type === 'tag-message') {
    if (typeof event.data.msgIndex === 'number' && event.data.tagId) toggleMessageTag(event.data.msgIndex, event.data.tagId);
  }
  if (event.data.type === 'filter-message-tags') {
    var filterTags = event.data.tags || [];
    document.querySelectorAll('#msgs .msg').forEach(function(msg, i) {
      if (!filterTags.length) { msg.classList.remove('tag-dimmed'); return; }
      var tags = messageTags[i] || [];
      msg.classList.toggle('tag-dimmed', !filterTags.some(function(t) { return tags.includes(t); }));
    });
  }
});

// ===== INIT DOM CACHE =====
initDomCache();
</script>
</body>
</html>
