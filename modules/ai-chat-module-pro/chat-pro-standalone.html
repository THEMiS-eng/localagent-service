<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LocalAgent Chat</title>
<style>
/* ============================================================
   THEME SYSTEM - Supports both standalone dark and embedded light
   When embedded in dashboard iframe, inherits parent theme via CSS vars
   ============================================================ */

/* Default: Dark theme (standalone mode) */
:root {
    --chat-bg: #0a0a0b;
    --chat-surface: #18181b;
    --chat-surface2: #1f1f23;
    --chat-border: #27272a;
    --chat-text: #fafafa;
    --chat-text2: #a1a1aa;
    --chat-muted: #71717a;
    --chat-accent: #6366f1;
    --chat-success: #22c55e;
    --chat-error: #ef4444;
    --chat-error-bg: rgba(239,68,68,.15);
    --chat-user-bg: #1e1b4b;
    --chat-code-bg: #0d0d0f;
    --chat-voice: #ef4444;
    --chat-warning: #f59e0b;
    --chat-input-bg: #111;
    
    /* Shared with dashboard - use fallback to dashboard vars */
    --accent: var(--blue, #6366f1);
    --success: var(--success, #22c55e);
    --error: var(--error, #ef4444);
    --warning: var(--warning, #f59e0b);
}

/* Light theme (when embedded in dashboard or explicit) */
:root.light, 
body.light,
:root[data-theme="light"] {
    --chat-bg: #ffffff;
    --chat-surface: #f8f9fa;
    --chat-surface2: #f1f3f4;
    --chat-border: #e0e0e0;
    --chat-text: #202124;
    --chat-text2: #5f6368;
    --chat-muted: #9aa0a6;
    --chat-accent: #1a73e8;
    --chat-success: #34a853;
    --chat-error: #ea4335;
    --chat-error-bg: rgba(234,67,53,.1);
    --chat-user-bg: #e8f0fe;
    --chat-code-bg: #f1f3f4;
    --chat-voice: #ea4335;
    --chat-warning: #fbbc04;
    --chat-input-bg: #f8f9fa;
}

/* Auto-detect: If parent has light background, switch to light theme */
@media (prefers-color-scheme: light) {
    :root:not(.dark):not([data-theme="dark"]) {
        --chat-bg: #ffffff;
        --chat-surface: #f8f9fa;
        --chat-surface2: #f1f3f4;
        --chat-border: #e0e0e0;
        --chat-text: #202124;
        --chat-text2: #5f6368;
        --chat-muted: #9aa0a6;
        --chat-accent: #1a73e8;
        --chat-success: #34a853;
        --chat-error: #ea4335;
        --chat-error-bg: rgba(234,67,53,.1);
        --chat-user-bg: #e8f0fe;
        --chat-code-bg: #f1f3f4;
        --chat-voice: #ea4335;
        --chat-warning: #fbbc04;
        --chat-input-bg: #f8f9fa;
    }
}

/* Legacy variable mapping for backward compatibility */
:root {
    --bg: var(--chat-bg);
    --surface: var(--chat-surface);
    --surface2: var(--chat-surface2);
    --border: var(--chat-border);
    --text: var(--chat-text);
    --text2: var(--chat-text2);
    --muted: var(--chat-muted);
    --accent: var(--chat-accent);
    --success: var(--chat-success);
    --error: var(--chat-error);
    --error-bg: var(--chat-error-bg);
    --user-bg: var(--chat-user-bg);
    --code-bg: var(--chat-code-bg);
    --voice: var(--chat-voice);
    --warning: var(--chat-warning);
    --linter-good: #166534;
    --linter-warn: #854d0e;
    --linter-bad: #991b1b;
}

*{box-sizing:border-box;margin:0;padding:0}
body{font-family:system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:transparent;color:var(--chat-text);width:100%;height:100vh;overflow:hidden;font-size:14px;display:flex;flex-direction:column;position:relative}
.chat{display:flex;flex-direction:column;height:100%;width:100%;max-width:none;margin:0;position:relative}
.header{display:flex;align-items:center;justify-content:space-between;padding:14px 20px;background:var(--chat-surface);border-bottom:1px solid var(--chat-border)}
.header-title{font-weight:600;color:var(--chat-text)}
.header-badge{font-size:10px;padding:3px 8px;background:var(--chat-muted);color:#fff;border-radius:10px;font-weight:500}
.header-badge.ready{background:var(--chat-success)}
.header-badge.loading{background:var(--chat-warning)}
.header-badge.recording{background:var(--chat-voice)}
.header-badge.processing{background:var(--chat-accent)}
.messages{flex:1;overflow-y:auto;padding:20px;display:flex;flex-direction:column;gap:18px}
.messages:not(:has(*)){display:none;padding:0}
.messages::-webkit-scrollbar{width:6px}.messages::-webkit-scrollbar-thumb{background:var(--chat-border);border-radius:3px}
.empty{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;color:var(--chat-muted);text-align:center;gap:10px}
.empty h2{color:var(--chat-text);font-size:16px}
.msg{display:flex;flex-direction:column;gap:8px;max-width:82%;animation:fadeIn .2s}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}
.msg.user{align-self:flex-end}.msg.assistant{align-self:flex-start}
.bubble{padding:12px 16px;border-radius:12px;line-height:1.55}
.msg.user .bubble{background:var(--chat-user-bg);border:1px solid var(--chat-accent);border-bottom-right-radius:4px}
.msg.assistant .bubble{background:var(--chat-surface);border:1px solid var(--chat-border);border-bottom-left-radius:4px}
.content{white-space:pre-wrap;word-break:break-word;color:var(--chat-text)}
.cursor{display:inline-block;width:2px;height:1em;background:var(--chat-accent);margin-left:2px;animation:pulse 1s infinite}
@keyframes pulse{50%{opacity:.3}}
code{background:var(--chat-code-bg);padding:2px 5px;border-radius:4px;font-size:13px;font-family:'SF Mono',Consolas,monospace;color:var(--chat-text)}
.code-block{margin:10px 0;background:var(--chat-code-bg);border:1px solid var(--chat-border);border-radius:8px;overflow:hidden}
.code-block header{display:flex;justify-content:space-between;padding:6px 10px;background:var(--chat-surface);border-bottom:1px solid var(--chat-border);font-size:11px;color:var(--chat-muted)}
.code-block pre{padding:12px;margin:0;font-size:12px;overflow-x:auto;font-family:'SF Mono',Consolas,monospace;line-height:1.5;color:var(--chat-text)}
.code-block button{background:none;border:none;color:var(--chat-muted);cursor:pointer;font-size:11px}

.steps-container{background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:10px;overflow:hidden}
.steps-header{display:flex;align-items:center;gap:8px;padding:10px 14px;cursor:pointer;font-size:13px;color:var(--chat-text2)}
.steps-header:hover{background:var(--chat-surface2)}
.steps-header svg{transition:transform .2s}
.steps-header.open svg{transform:rotate(90deg)}
.steps-header .count{color:var(--chat-muted);font-size:12px}
.steps-body{display:none;border-top:1px solid var(--chat-border)}
.steps-body.open{display:block}
.step{border-bottom:1px solid var(--chat-border)}
.step:last-child{border-bottom:none}
.step-header{display:flex;align-items:center;gap:10px;padding:10px 14px;cursor:pointer;font-size:13px}
.step-header:hover{background:var(--chat-surface2)}
.step-icon{width:20px;height:20px;display:flex;align-items:center;justify-content:center}
.step-icon.running{color:var(--chat-accent)}
.step-icon.success{color:var(--chat-success)}
.step-icon.error{color:var(--chat-error)}
.step-title{flex:1;font-weight:500;color:var(--chat-text)}
.step-time{font-size:11px;color:var(--chat-muted);font-family:'SF Mono',monospace}
.step-content{display:none;padding:0 14px 12px 44px}
.step-content.open{display:block}
.step-cmd{background:var(--chat-bg);border-radius:6px;padding:10px 12px;font-family:'SF Mono',monospace;font-size:12px;color:var(--chat-text2)}
.step-error{background:var(--chat-error-bg);border:1px solid var(--chat-error);border-radius:6px;padding:10px 12px;margin-top:8px}
.step-error-title{font-weight:600;color:var(--chat-error);margin-bottom:6px;font-size:12px}
.step-error pre{font-family:'SF Mono',monospace;font-size:11px;color:var(--chat-error);white-space:pre-wrap;margin:0}

.meta{font-size:11px;color:var(--chat-muted);margin-top:8px}
.files{display:flex;flex-wrap:wrap;gap:6px;margin-top:10px}
.file{display:flex;align-items:center;gap:6px;padding:6px 10px;background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:6px;font-size:12px}
.file-icon{color:var(--chat-accent)}
.file-name{max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--chat-text)}
.file-size{color:var(--chat-muted);font-size:10px}
.file-remove{background:none;border:none;color:var(--chat-muted);cursor:pointer;padding:2px;display:flex}
.file-remove:hover{color:var(--chat-error)}

.input-area{padding:12px 16px;background:transparent;border-top:none;position:relative;width:100%}

/* ============================================================
   COLLAPSED INPUT - fits in 64px footer
   ============================================================ */
.collapsed-input{
    display:flex;
    align-items:center;
    padding:8px 16px;
    height:64px;
    width:100%;
    flex-shrink:0;
    margin-top:auto;
}
.collapsed-input .input-box-mini{
    flex:1;
    display:flex;
    align-items:center;
    gap:8px;
    background:var(--chat-surface);
    border:1px solid var(--chat-border);
    border-radius:12px;
    padding:6px 8px 6px 14px;
    width:100%;
}
.collapsed-input .input-box-mini:focus-within{
    border-color:var(--chat-accent);
    box-shadow:0 0 0 2px rgba(99,102,241,.12);
}
.collapsed-input .input-box-mini input{
    flex:1;
    border:none;
    background:none;
    outline:none;
    font-size:14px;
    color:var(--chat-text);
}
.collapsed-input .input-box-mini input::placeholder{color:var(--chat-muted)}
.collapsed-input.hidden{visibility:hidden}

/* ============================================================
   EXPANDED OVERLAY - covers footer, overlays body
   ============================================================ */
.expanded-overlay{
    display:none;
    position:absolute;
    bottom:0;
    left:0;
    right:0;
    background:var(--chat-bg);
    border-top:1px solid var(--chat-border);
    z-index:50;
    width:100%;
}
.expanded-overlay.visible{display:block}
.input-files{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:10px}

/* ============================================================
   PROMPT LINTER BAR - Real-time analysis
   ============================================================ */
.linter-bar{
    display:none;
    padding:10px 14px;
    margin-bottom:12px;
    border-radius:10px;
    align-items:center;
    gap:12px;
    font-size:12px;
    background:var(--chat-surface);
    border:1px solid var(--chat-border);
}
.linter-bar.visible{display:flex}
.linter-bar.good{background:rgba(34,197,94,0.1);border-color:var(--chat-success)}
.linter-bar.warn{background:rgba(245,158,11,0.1);border-color:var(--chat-warning)}
.linter-bar.bad{background:var(--chat-error-bg);border-color:var(--chat-error)}

.linter-score{
    font-weight:700;
    padding:4px 10px;
    border-radius:8px;
    font-size:13px;
    min-width:55px;
    text-align:center;
}
.linter-bar.good .linter-score{background:var(--chat-success);color:#fff}
.linter-bar.warn .linter-score{background:var(--chat-warning);color:#000}
.linter-bar.bad .linter-score{background:var(--chat-error);color:#fff}

.linter-meta{
    display:flex;
    gap:10px;
    color:var(--chat-text2);
    font-size:11px;
    flex-shrink:0;
}
.linter-meta span{
    display:flex;
    align-items:center;
    gap:3px;
    padding:3px 8px;
    background:var(--chat-surface2);
    border-radius:6px;
}

.linter-issues{
    display:flex;
    gap:6px;
    flex:1;
    overflow-x:auto;
    padding:2px 0;
}
.linter-issue{
    padding:4px 8px;
    border-radius:6px;
    font-size:11px;
    white-space:nowrap;
    font-weight:500;
}
.linter-issue.high{background:rgba(239,68,68,0.15);color:var(--chat-error)}
.linter-issue.medium{background:rgba(245,158,11,0.15);color:var(--chat-warning)}
.linter-issue.low{background:rgba(34,197,94,0.15);color:var(--chat-success)}

.linter-fix-btn{
    padding:6px 12px;
    background:linear-gradient(135deg, var(--chat-accent) 0%, #8b5cf6 100%);
    color:#fff;
    border:none;
    border-radius:6px;
    font-weight:500;
    cursor:pointer;
    font-size:11px;
    transition:all .15s;
    white-space:nowrap;
    position:relative;
    z-index:9999;
    pointer-events:auto;
}
.linter-fix-btn:hover{
    transform:translateY(-1px);
    box-shadow:0 4px 12px rgba(99,102,241,0.4);
}

.linter-preview{
    display:none;
    padding:8px 12px;
    margin-top:8px;
    border-radius:8px;
    background:rgba(99,102,241,0.08);
    border:1px solid rgba(99,102,241,0.2);
    font-size:11px;
    max-height:120px;
    overflow-y:auto;
}
.linter-preview.visible{display:block}
.linter-preview-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:6px;
    font-weight:600;
    color:var(--chat-accent);
}
.linter-preview-diff{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px;
}
.linter-preview-col{
    padding:6px 8px;
    border-radius:6px;
    font-family:monospace;
    font-size:10px;
    line-height:1.4;
    white-space:pre-wrap;
    word-break:break-word;
}
.linter-preview-col.original{
    background:rgba(239,68,68,0.1);
    border:1px solid rgba(239,68,68,0.2);
    text-decoration:line-through;
    color:var(--chat-muted);
}
.linter-preview-col.fixed{
    background:rgba(34,197,94,0.1);
    border:1px solid rgba(34,197,94,0.2);
    color:var(--chat-success);
}
.linter-preview-label{
    font-size:9px;
    font-weight:600;
    text-transform:uppercase;
    margin-bottom:4px;
    opacity:0.7;
}

.input-row{display:flex;gap:10px}
.input-box{flex:1;display:flex;flex-direction:column;background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:14px;overflow:hidden}
.input-box:focus-within{border-color:var(--chat-accent);box-shadow:0 0 0 3px rgba(99,102,241,.12)}
.input-line1{padding:12px 14px 8px}
.input-line1 textarea{width:100%;background:none;border:none;color:var(--chat-text);font:inherit;font-size:15px;resize:none;outline:none;min-height:24px;max-height:120px;line-height:1.5}
.input-line1 textarea::placeholder{color:var(--chat-muted)}
.input-line2{display:flex;align-items:center;gap:4px;padding:8px 10px;border-top:1px solid var(--chat-border);background:var(--chat-surface2);position:relative;z-index:10}

/* All buttons standardized at 32px */
.input-btn{width:32px;height:32px;border:none;background:transparent;border-radius:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--chat-muted);font-size:12px;font-weight:600;transition:all .15s}
.input-btn:hover{background:rgba(99,102,241,.1);color:var(--chat-text)}
.input-btn.active{background:var(--chat-accent);color:#fff}
.input-btn svg{width:16px;height:16px;stroke:currentColor;stroke-width:1.5;fill:none}
.input-btn.mode-btn{font-weight:700;background:var(--chat-accent);color:#fff}
.input-btn.mode-btn:hover{opacity:0.9}

.send-btn{width:32px;height:32px;background:var(--chat-accent);border:none;border-radius:8px;color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:all .15s}
.send-btn:hover:not(:disabled){opacity:0.9}
.send-btn:disabled{background:#d1d5db;cursor:not-allowed}
.send-btn.stop{background:var(--chat-error)}
.send-btn svg{width:14px;height:14px}

/* DA Popup */
.da-popup{position:absolute;bottom:100%;left:10px;width:300px;background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 -4px 24px rgba(0,0,0,.15);z-index:99999;display:none;max-height:300px;overflow:auto;margin-bottom:8px}
.da-popup.visible{display:block}

.input-divider{width:1px;height:20px;background:var(--chat-border);margin:0 4px}
.input-spacer{flex:1}
.input-counter{min-width:20px;height:20px;padding:0 5px;background:var(--chat-accent);color:#fff;border-radius:10px;font-size:11px;font-weight:600;display:none;align-items:center;justify-content:center}
.input-counter.visible{display:flex}
.da-section{border-bottom:1px solid var(--chat-border)}
.da-section:last-child{border-bottom:none}
.da-header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;cursor:pointer;user-select:none}
.da-header:hover{background:var(--chat-surface)}
.da-header-title{font-size:11px;font-weight:600;color:var(--chat-muted);letter-spacing:0.5px}
.da-header-add{font-size:14px;color:var(--chat-muted);width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:4px}
.da-header-add:hover{background:var(--chat-surface2)}
.da-body{display:none;padding:0 8px 8px;max-height:180px;overflow-y:auto}
.da-body.open{display:block}
.da-item{display:flex;align-items:center;gap:10px;padding:10px;border-radius:8px;cursor:pointer;margin-bottom:4px}
.da-item:hover{background:var(--chat-surface)}
.da-item.active{background:rgba(99,102,241,.1)}
.da-item-icon{width:36px;height:36px;border-radius:8px;background:rgba(99,102,241,.1);display:flex;align-items:center;justify-content:center;color:var(--chat-accent);font-size:14px}
.da-item-info{flex:1;min-width:0}
.da-item-name{font-size:13px;font-weight:500;color:var(--chat-text);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.da-item-desc{font-size:11px;color:var(--chat-muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.da-item-status{font-size:10px;color:var(--chat-accent);font-weight:500}
.da-empty{padding:16px;text-align:center;color:var(--chat-muted);font-size:12px}
/* Legacy support */
.attach-btn,.voice-btn{background:none;border:none;color:var(--chat-muted);cursor:pointer;padding:6px;border-radius:6px;display:flex;transition:all .15s}
.attach-btn:hover{color:var(--chat-accent);background:rgba(99,102,241,.1)}
.voice-btn:hover{color:var(--chat-voice);background:rgba(239,68,68,.1)}
.voice-btn.loading{color:var(--chat-warning)}
.voice-btn.ready{color:var(--chat-success)}
.voice-btn.recording{color:#fff;background:var(--chat-voice);animation:voicePulse 1.5s ease-in-out infinite}
.voice-btn.processing{color:var(--chat-accent)}
@keyframes voicePulse{0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,.4)}50%{box-shadow:0 0 0 8px rgba(239,68,68,0)}}
textarea{flex:1;background:none;border:none;color:var(--chat-text);font:inherit;font-size:14px;resize:none;outline:none;min-height:24px;max-height:200px;line-height:1.5}
textarea::placeholder{color:var(--chat-muted)}

.voice-status{display:none;align-items:center;gap:10px;padding:12px 14px;background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:10px;margin-bottom:12px;font-size:13px;color:var(--chat-text)}
.voice-status.active{display:flex}
.voice-status.recording{border-color:var(--chat-voice);background:rgba(239,68,68,.08)}
.voice-status.processing{border-color:var(--chat-accent);background:rgba(99,102,241,.08)}
.voice-status.loading{border-color:var(--chat-warning);background:rgba(245,158,11,.08)}
.voice-status .status-icon{display:flex}
.voice-status .status-text{flex:1;color:var(--chat-text)}
.voice-status .status-detail{font-size:11px;color:var(--chat-muted);margin-top:2px}
.voice-status .stop-btn{background:var(--chat-voice);border:none;color:#fff;cursor:pointer;font-size:12px;padding:8px 16px;border-radius:6px;font-weight:500}
.voice-status .stop-btn:hover{opacity:0.9}
.voice-status .cancel-btn{background:none;border:1px solid var(--chat-border);color:var(--chat-text2);cursor:pointer;font-size:11px;padding:6px 12px;border-radius:6px}
.voice-status .cancel-btn:hover{border-color:var(--chat-error);color:var(--chat-error)}

.waveform{display:flex;align-items:center;gap:2px;height:24px;padding:0 8px}
.waveform-bar{width:3px;background:var(--chat-voice);border-radius:2px;transition:height 0.05s}

.progress{height:6px;background:var(--chat-bg);border-radius:3px;overflow:hidden;margin-top:6px}
.progress-bar{height:100%;background:var(--chat-accent);transition:width .3s}

.drop-zone{position:fixed;inset:0;background:rgba(99,102,241,.08);border:3px dashed var(--chat-accent);display:none;flex-direction:column;align-items:center;justify-content:center;gap:12px;color:var(--chat-accent);font-size:16px;font-weight:500;z-index:100}
.drop-zone.active{display:flex}
.scroll-btn{position:fixed;bottom:90px;right:20px;width:36px;height:36px;background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:50%;display:none;align-items:center;justify-content:center;color:var(--chat-text);cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,.15)}
.scroll-btn.visible{display:flex}

@keyframes spin{to{transform:rotate(360deg)}}
.spin{animation:spin .8s linear infinite}
</style>
</head>
<body>
<div class="chat">
<div class="messages" id="msgs"></div>
<button class="scroll-btn" id="scrollBtn"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M19 12l-7 7-7-7"/></svg></button>

<!-- EXPANDED OVERLAY - appears when typing -->
<div class="expanded-overlay" id="expandedOverlay">
<div class="input-area">
<div class="voice-status" id="voiceStatus">
<span class="status-icon" id="statusIcon"></span>
<div style="flex:1">
<div class="status-text" id="statusText">Loading...</div>
<div class="status-detail" id="statusDetail"></div>
<div class="progress" id="progressContainer" style="display:none"><div class="progress-bar" id="progressBar"></div></div>
</div>
<div class="waveform" id="waveform" style="display:none"></div>
<button class="stop-btn" id="stopBtn" style="display:none">Stop & Transcribe</button>
<button class="cancel-btn" id="cancelBtn">Cancel</button>
</div>

<!-- PROMPT LINTER BAR -->
<div class="linter-bar" id="linterBar">
    <div class="linter-score" id="linterScore">100</div>
    <div class="linter-meta">
        <span id="linterLang">üåç EN</span>
        <span id="linterTask">üéØ unknown</span>
        <span id="linterTokens">üìä ~0</span>
        <span id="linterCost">üí∞ $0.000</span>
    </div>
    <div class="linter-issues" id="linterIssues"></div>
    <button class="linter-fix-btn" id="linterFixBtn" style="display:none" onclick="window.applyFix(); return false;">‚ú® Auto-fix</button>
</div>
<div class="linter-preview" id="linterPreview">
    <div class="linter-preview-header">
        <span>üîÑ Rewrite Preview</span>
        <span style="font-weight:400;font-size:10px;color:var(--chat-muted)">Click Auto-fix to apply</span>
    </div>
    <div class="linter-preview-diff">
        <div class="linter-preview-col original">
            <div class="linter-preview-label">Original</div>
            <div id="previewOriginal"></div>
        </div>
        <div class="linter-preview-col fixed">
            <div class="linter-preview-label">Auto-fixed</div>
            <div id="previewFixed"></div>
        </div>
    </div>
</div>

<div class="input-files" id="inputFiles"></div>
<div class="input-row">
<div class="input-box">
<div class="input-line1">
<textarea id="input" placeholder="Ask about your documents..." rows="1"></textarea>
</div>
<div class="input-line2">
<button class="input-btn mode-btn" id="btnMode" title="Toggle Search/Analysis"><strong>S</strong></button>
<button class="input-btn" id="btnDA" title="Assistants & Skills">DA</button>
<button class="input-btn" id="btnFav" title="Saved Prompts"><svg viewBox="0 0 24 24"><path d="M12 2l3 6 7 1-5 5 1 7-6-3-6 3 1-7-5-5 7-1z"/></svg></button>
<button class="input-btn" id="btnSearch" title="Search History"><svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="7"/><path d="M21 21l-4-4"/></svg></button>
<div class="input-divider"></div>
<button class="input-btn" id="btnTags" title="Tags"><svg viewBox="0 0 24 24"><path d="M4 4h6l10 10-6 6L4 10V4z"/><circle cx="8" cy="8" r="1.5"/></svg></button>
<button class="input-btn" id="attachBtn" title="Attach Files"><svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
<button class="input-btn" id="voiceBtn" title="Voice Input"><svg viewBox="0 0 24 24"><path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/><path d="M19 10v2a7 7 0 01-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/></svg></button>
<div class="input-spacer"></div>
<div class="input-counter" id="fileCounter">0</div>
<button class="send-btn" id="send" disabled><svg viewBox="0 0 24 24"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4z"/></svg></button>
</div>
</div>
</div>
<!-- DA Popup - Outside input-box for proper z-index -->
<div class="da-popup" id="daPopup">
<div class="da-section">
<div class="da-header" id="daAssistantsHeader"><span class="da-header-title">‚ñæ ASSISTANTS</span><span class="da-header-add">+</span></div>
<div class="da-body open" id="daAssistantsBody"><div class="da-empty">Loading skills...</div></div>
</div>
<div class="da-section">
<div class="da-header" id="daStyleHeader"><span class="da-header-title">‚ñ∏ STYLE & TONE</span><span class="da-header-add">+</span></div>
<div class="da-body" id="daStyleBody"><div class="da-empty">Coming soon</div></div>
</div>
<div class="da-section">
<div class="da-header" id="daSystemHeader"><span class="da-header-title">‚ñ∏ SYSTEM</span><span class="da-header-add">+</span></div>
<div class="da-body" id="daSystemBody"><div class="da-empty">Coming soon</div></div>
</div>
</div>
</div>
</div>
<!-- END EXPANDED OVERLAY -->

<!-- COLLAPSED INPUT - fits in 64px footer -->
<div class="collapsed-input" id="collapsedInput">
    <div class="input-box-mini">
        <input type="text" id="inputCollapsed" placeholder="Ask about your documents...">
        <button class="input-btn mode-btn" id="btnModeCollapsed"><strong>S</strong></button>
        <button class="send-btn" id="sendCollapsed" disabled><svg viewBox="0 0 24 24"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4z"/></svg></button>
    </div>
</div>

</div>
<input type="file" id="fileInput" multiple hidden>
<div class="drop-zone" id="dropZone"><svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48"/></svg>Drop files here</div>

<!-- External Linter Bundle -->
<script src="./PromptLinter.bundle.js"></script>

<script>
// ===== ERROR CAPTURE - Send to parent dashboard =====
(function setupErrorCapture() {
  const API_BASE = window.LOCALAGENT_API || window.location.origin || 'http://localhost:9998';
  
  // Track the last LLM response for error correction
  let lastLLMResponse = null;
  let lastUserPrompt = null;
  let lastMessageId = null;
  let lastSkillUsed = null;
  let lastCaseId = null;
  let isCorrectingError = false;
  
  // Export for use in main code
  window.setLastLLMContext = function(response, prompt, msgId, skill, caseId) {
    lastLLMResponse = response;
    lastUserPrompt = prompt;
    lastMessageId = msgId || Date.now().toString();
    lastSkillUsed = skill;
    lastCaseId = caseId;
  };
  
  function sendError(level, message) {
    // Send to parent window if in iframe
    if (window.parent !== window) {
      try {
        window.parent.postMessage({type: 'chat-error', level, message}, '*');
      } catch(e) {}
    }
    
    // Send to debug endpoint
    fetch(`${API_BASE}/api/debug/error`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        level: level,
        message: message,
        source: 'chat-module',
        timestamp: new Date().toISOString()
      })
    }).catch(() => {});
  }
  
  // Trigger error correction with Negotiator
  async function triggerErrorCorrection(errorMessage, codeContext) {
    if (isCorrectingError) {
      console.log('[Chat] Already correcting an error, skipping...');
      return;
    }
    
    if (!lastLLMResponse || !lastUserPrompt) {
      console.log('[Chat] No LLM context to correct');
      return;
    }
    
    isCorrectingError = true;
    console.log('[Chat] Triggering error correction for:', errorMessage.substring(0, 100));
    
    // Show correction UI
    const event = new CustomEvent('negotiator-correction', {
      detail: { status: 'started', error: errorMessage }
    });
    window.dispatchEvent(event);
    
    try {
      const response = await fetch(`${API_BASE}/themis/api/chat/error`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          message_id: lastMessageId,
          error_message: errorMessage,
          code_context: codeContext || '',
          original_prompt: lastUserPrompt,
          original_response: lastLLMResponse,
          case_id: lastCaseId,
          skill_used: lastSkillUsed
        })
      });
      
      const data = await response.json();
      
      if (data.success && data.response) {
        console.log('[Chat] Correction received, retry:', data.retry_count);
        
        // Dispatch correction event
        const correctionEvent = new CustomEvent('negotiator-correction', {
          detail: { 
            status: 'corrected', 
            response: data.response,
            retry_count: data.retry_count,
            error_type: data.error_type,
            protocol: data.protocol
          }
        });
        window.dispatchEvent(correctionEvent);
        
        // Update context for next potential error
        lastLLMResponse = data.response;
      } else {
        console.log('[Chat] Correction failed:', data.error);
        const failEvent = new CustomEvent('negotiator-correction', {
          detail: { status: 'failed', error: data.error }
        });
        window.dispatchEvent(failEvent);
      }
    } catch (e) {
      console.error('[Chat] Error correction request failed:', e);
    } finally {
      isCorrectingError = false;
    }
  }
  
  // Check if error is likely from LLM-generated code
  function isLLMCodeError(message, source) {
    // Errors from inline scripts or eval are likely LLM code
    if (source && (source.includes('eval') || source.includes('blob:') || source.includes('inline'))) {
      return true;
    }
    // Common LLM code errors
    const llmErrorPatterns = [
      /Unexpected token/,
      /is not defined/,
      /is not a function/,
      /Cannot read propert/,
      /SyntaxError/,
      /ReferenceError/,
      /TypeError/
    ];
    return llmErrorPatterns.some(p => p.test(message));
  }
  
  window.onerror = function(msg, src, line, col, err) {
    const errorMsg = `${msg} at ${src}:${line}:${col}`;
    sendError('error', errorMsg);
    
    // Check if this is an LLM code error that needs correction
    if (lastLLMResponse && isLLMCodeError(msg, src)) {
      triggerErrorCorrection(errorMsg, lastLLMResponse.substring(0, 1000));
    }
    
    return false;
  };
  
  window.onunhandledrejection = function(e) {
    const errorMsg = `Unhandled Promise: ${e.reason}`;
    sendError('error', errorMsg);
    
    if (lastLLMResponse && isLLMCodeError(String(e.reason), '')) {
      triggerErrorCorrection(errorMsg, lastLLMResponse.substring(0, 1000));
    }
  };
  
  // Intercept console.error
  const origError = console.error;
  console.error = function(...args) {
    origError.apply(console, args);
    const errorMsg = args.map(a => String(a)).join(' ');
    sendError('error', errorMsg);
    
    // Trigger correction for significant errors
    if (lastLLMResponse && isLLMCodeError(errorMsg, '')) {
      triggerErrorCorrection(errorMsg, lastLLMResponse.substring(0, 1000));
    }
  };
})();

// ===== THEME DETECTION =====
// Auto-detect if embedded in light-themed dashboard
(function detectTheme() {
  // Check URL parameter
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('theme') === 'light') {
    document.documentElement.classList.add('light');
    return;
  }
  if (urlParams.get('theme') === 'dark') {
    document.documentElement.classList.add('dark');
    return;
  }
  
  // Check if embedded in iframe with light parent
  try {
    if (window.parent !== window) {
      const parentBg = window.parent.document.body.style.backgroundColor ||
                       window.parent.getComputedStyle(window.parent.document.body).backgroundColor;
      if (parentBg) {
        // Parse RGB and check if it's light
        const rgb = parentBg.match(/\d+/g);
        if (rgb && rgb.length >= 3) {
          const brightness = (parseInt(rgb[0]) * 299 + parseInt(rgb[1]) * 587 + parseInt(rgb[2]) * 114) / 1000;
          if (brightness > 128) {
            document.documentElement.classList.add('light');
            return;
          }
        }
      }
    }
  } catch (e) {
    // Cross-origin iframe, can't access parent
  }
  
  // Check system preference
  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
    // System prefers light, but we default to dark for standalone
    // Only apply if explicitly requested
  }
  
  // Default: dark theme (already set in CSS)
})();

// ===== EXPOSE THEME API =====
window.LocalAgentChat = {
  setTheme: (theme) => {
    document.documentElement.classList.remove('light', 'dark');
    if (theme === 'light' || theme === 'dark') {
      document.documentElement.classList.add(theme);
    }
  },
  getTheme: () => {
    if (document.documentElement.classList.contains('light')) return 'light';
    if (document.documentElement.classList.contains('dark')) return 'dark';
    return 'auto';
  }
};

const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);
const delay = ms => new Promise(r => setTimeout(r, ms));
const esc = s => String(s).replace(/</g,'&lt;').replace(/>/g,'&gt;');
const time = () => new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});
const formatSize = b => {
  if(!b) return '0 B';
  const k=1024, s=['B','KB','MB'];
  const i = Math.floor(Math.log(b)/Math.log(k));
  return (b/Math.pow(k,i)).toFixed(1)+' '+s[i];
};

const icons = {
  chevron:'<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>',
  running:'<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spin"><path d="M21 12a9 9 0 11-6.219-8.56"/></svg>',
  success:'<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><path d="M22 4L12 14.01l-3-3"/></svg>',
  error:'<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M15 9l-6 6M9 9l6 6"/></svg>',
  mic:'<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/><path d="M19 10v2a7 7 0 01-14 0v-2"/></svg>',
  file:'<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><path d="M14 2v6h6"/></svg>'
};

// ===== STATE =====
let generating = false;
let files = [];
let whisper = null;  // WhisperTranscriber instance
let micPermissionGranted = false;
let isRecording = false;
let animationId = null;
let currentStream = null;
let recordedSamples = [];
let lastInputSource = 'text'; // 'text' or 'voice'
let audioContext = null;
let conversationHistory = []; // Store message history for context

// ===== LINTER UI (uses external PromptLinter.bundle.js) =====
let lintTimer = null;
let lastLintResult = null;

function debounceLint() {
  clearTimeout(lintTimer);
  lintTimer = setTimeout(runLint, 350);
}

async function runLint() {
  const text = $('#input').value.trim();
  const bar = $('#linterBar');
  const fixBtn = $('#linterFixBtn');
  
  if (!text || text.length < 3) {
    bar.classList.remove('visible');
    $('#linterPreview').classList.remove('visible');
    return;
  }
  
  if (!window.PromptLinter) {
    console.warn('PromptLinter not loaded');
    return;
  }
  
  const result = await window.PromptLinter.lintPromptAsync(text);
  lastLintResult = result;
  
  // Update score
  $('#linterScore').textContent = result.score;
  
  // Update bar class
  bar.classList.remove('good', 'warn', 'bad');
  if (result.score >= 80) bar.classList.add('good');
  else if (result.score >= 50) bar.classList.add('warn');
  else bar.classList.add('bad');
  bar.classList.add('visible');
  
  // Update meta
  $('#linterLang').textContent = 'üåç ' + result.lang.toUpperCase();
  $('#linterTask').textContent = 'üéØ ' + (result.topRewrite ? result.topRewrite.skill : result.taskType);
  $('#linterTokens').textContent = 'üìä ~' + (result.tokens.input + result.tokens.output);
  $('#linterCost').textContent = 'üí∞ $' + result.tokens.cost;
  
  // Update issues
  $('#linterIssues').innerHTML = result.issues.map(i => 
    `<span class="linter-issue ${i.severity}" title="${i.fix}">${i.message}</span>`
  ).join('');
  
  // Show preview if there are rewrites or changes
  const preview = $('#linterPreview');
  const hasRewrites = result.rewrites && result.rewrites.length > 0;
  const hasChanges = result.optimized !== text;
  
  // Remove old skill buttons
  const oldSkillDiv = document.querySelector('.skill-rewrites');
  if (oldSkillDiv) oldSkillDiv.remove();
  
  if (hasRewrites) {
    fixBtn.style.display = 'block';
    
    // Build rewrite preview
    let html = '<div class="skill-rewrites" style="margin-top:8px">';
    html += '<div style="font-size:10px;color:var(--chat-muted);margin-bottom:6px;font-weight:600">üí° SKILL REWRITES:</div>';
    
    for (const rw of result.rewrites) {
      const truncated = rw.template.length > 150 ? rw.template.slice(0, 150) + '...' : rw.template;
      const encodedTemplate = encodeURIComponent(rw.template);
      html += `<div class="rewrite-option" data-template="${encodedTemplate}" data-skill="${rw.skill}" style="margin:4px 0;padding:8px;background:var(--chat-surface);border:1px solid var(--chat-border);border-radius:6px;cursor:pointer">`;
      html += `<div style="font-size:11px;font-weight:600;color:var(--chat-accent);margin-bottom:4px">${rw.skill} [${rw.patterns.join(', ')}]</div>`;
      html += `<div style="font-size:11px;color:var(--chat-text);white-space:pre-wrap;font-family:var(--chat-mono,monospace)">${truncated}</div>`;
      html += '</div>';
    }
    html += '</div>';
    
    $('#previewOriginal').textContent = text;
    $('#previewFixed').textContent = result.topRewrite.template;
    preview.querySelector('.linter-preview-diff').insertAdjacentHTML('afterend', html);
    preview.classList.add('visible');
  } else if (hasChanges) {
    fixBtn.style.display = 'block';
    $('#previewOriginal').textContent = text;
    $('#previewFixed').textContent = result.optimized;
    preview.classList.add('visible');
  } else {
    fixBtn.style.display = 'none';
    preview.classList.remove('visible');
  }
}

window.applyFix = function() {
  console.log('[Chat] applyFix called, lastLintResult:', lastLintResult);
  
  if (!lastLintResult) {
    console.error('[Chat] No lastLintResult!');
    return;
  }
  
  // Prefer topRewrite template if available, otherwise use optimized
  let newValue = null;
  
  if (lastLintResult.topRewrite && lastLintResult.topRewrite.template) {
    newValue = lastLintResult.topRewrite.template;
    console.log('[Chat] Using topRewrite template');
  } else if (lastLintResult.rewrites && lastLintResult.rewrites.length > 0) {
    newValue = lastLintResult.rewrites[0].template;
    console.log('[Chat] Using first rewrite template');
  } else if (lastLintResult.optimized) {
    newValue = lastLintResult.optimized;
    console.log('[Chat] Using optimized');
  }
  
  if (!newValue) {
    console.error('[Chat] No newValue to apply!');
    return;
  }
  
  console.log('[Chat] Applying value of length:', newValue.length);
  
  // Set the input value
  const inputEl = document.querySelector('#input');
  if (inputEl) {
    inputEl.value = newValue;
    console.log('[Chat] Set input.value');
  } else {
    console.error('[Chat] #input not found!');
  }
  
  // Hide preview
  const previewEl = document.querySelector('#linterPreview');
  if (previewEl) previewEl.classList.remove('visible');
  
  // Remove skill rewrites div
  const oldDiv = document.querySelector('.skill-rewrites');
  if (oldDiv) oldDiv.remove();
  
  // Resize
  if (typeof autoResize === 'function') autoResize();
  
  // Enable send buttons
  const sendBtn = document.querySelector('#send');
  const sendCollapsed = document.querySelector('#sendCollapsed');
  const inputCollapsed = document.querySelector('#inputCollapsed');
  
  if (sendBtn) sendBtn.disabled = false;
  if (sendCollapsed) sendCollapsed.disabled = false;
  if (inputCollapsed) inputCollapsed.value = newValue;
  
  console.log('[Chat] Send button enabled, running lint...');
  
  // Re-run lint on new content
  if (typeof runLint === 'function') runLint();
};
console.log('[Chat] window.applyFix DEFINED:', typeof window.applyFix === 'function');

window.applyRewrite = function(encodedTemplate, skillName) {
  console.log('[Chat] applyRewrite called for skill:', skillName);
  
  const template = decodeURIComponent(encodedTemplate);
  console.log('[Chat] Template length:', template.length);
  
  // Set the input value
  const inputEl = document.querySelector('#input');
  if (inputEl) {
    inputEl.value = template;
  }
  
  // Hide preview
  const previewEl = document.querySelector('#linterPreview');
  if (previewEl) previewEl.classList.remove('visible');
  
  // Remove skill rewrites div
  const oldDiv = document.querySelector('.skill-rewrites');
  if (oldDiv) oldDiv.remove();
  
  // Activate the skill (async but we don't need to wait)
  if (window.PromptLinter && window.PromptLinter.activateSkill) {
    window.PromptLinter.activateSkill(skillName);
  }
  
  // Resize
  if (typeof autoResize === 'function') autoResize();
  
  // Enable send buttons
  const sendBtn = document.querySelector('#send');
  const sendCollapsed = document.querySelector('#sendCollapsed');
  const inputCollapsed = document.querySelector('#inputCollapsed');
  
  if (sendBtn) sendBtn.disabled = false;
  if (sendCollapsed) sendCollapsed.disabled = false;
  if (inputCollapsed) inputCollapsed.value = template;
  
  console.log('[Chat] Rewrite applied, running lint...');
  
  // Re-run lint
  if (typeof runLint === 'function') runLint();
};

window.applySkill = async function(skillName) {
  const success = await window.PromptLinter.activateSkill(skillName);
  if (success) {
    console.log('[Chat] Skill activated:', skillName);
    $('#linterTask').textContent = 'üéØ ' + skillName;
    const skillDiv = document.querySelector('.skill-suggestions');
    if (skillDiv) skillDiv.remove();
  }
};

// ===== UI =====
function updateUI(state, detail = '') {
  const status = $('#voiceStatus');
  const btn = $('#voiceBtn');
  const badge = $('#badge'); // May be null if header removed
  
  status.className = 'voice-status';
  btn.className = 'input-btn';
  if (badge) badge.className = 'header-badge';
  
  $('#stopBtn').style.display = 'none';
  $('#waveform').style.display = 'none';
  $('#progressContainer').style.display = 'none';
  
  switch(state) {
    case 'idle':
      status.classList.remove('active');
      if (badge) badge.textContent = 'VOICE OFF';
      break;
      
    case 'loading':
      status.classList.add('active', 'loading');
      $('#statusIcon').innerHTML = icons.running;
      $('#statusText').textContent = detail || 'Loading...';
      $('#progressContainer').style.display = 'block';
      btn.classList.add('loading');
      if (badge) {
        badge.textContent = 'LOADING';
        badge.classList.add('loading');
      }
      break;
      
    case 'ready':
      status.classList.remove('active');
      btn.classList.add('ready');
      if (badge) {
        badge.textContent = 'VOICE READY';
        badge.classList.add('ready');
      }
      break;
      
    case 'recording':
      status.classList.add('active', 'recording');
      $('#statusIcon').innerHTML = icons.mic;
      $('#statusText').textContent = 'Recording...';
      $('#statusDetail').textContent = detail || 'Click "Stop" when done';
      $('#waveform').style.display = 'flex';
      $('#stopBtn').style.display = 'block';
      btn.classList.add('recording');
      if (badge) {
        badge.textContent = 'RECORDING';
        badge.classList.add('recording');
      }
      break;
      
    case 'processing':
      status.classList.add('active', 'processing');
      $('#statusIcon').innerHTML = icons.running;
      $('#statusText').textContent = 'Transcribing...';
      $('#statusDetail').textContent = detail || 'Processing locally with Whisper';
      btn.classList.add('processing');
      if (badge) {
        badge.textContent = 'PROCESSING';
        badge.classList.add('processing');
      }
      break;
      
    case 'error':
      status.classList.add('active');
      status.style.borderColor = 'var(--error)';
      $('#statusIcon').innerHTML = icons.error;
      $('#statusText').textContent = 'Error';
      $('#statusDetail').textContent = detail;
      if (badge) badge.textContent = 'ERROR';
      setTimeout(() => updateUI(whisper?.isLoaded() ? 'ready' : 'idle'), 3000);
      break;
  }
}

// ===== LOAD WHISPER MODULE =====
async function loadWhisperModule() {
  if (whisper?.isLoaded()) return true;
  
  updateUI('loading', 'Loading Whisper module...');
  $('#statusDetail').textContent = '~250MB, cached after first load';
  $('#progressBar').style.width = '0%';
  
  try {
    // Load WhisperTranscriber via script tag if not already loaded
    if (!window.WhisperTranscriber) {
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = '../whisper-module/WhisperTranscriber.js';
        script.onload = resolve;
        script.onerror = () => reject(new Error('Failed to load WhisperTranscriber'));
        document.head.appendChild(script);
      });
    }
    
    whisper = new window.WhisperTranscriber();
    
    await whisper.load('whisper-small', (p) => {
      if (p.progress !== null) {
        $('#progressBar').style.width = p.progress + '%';
        $('#statusDetail').textContent = p.progress + '%';
      }
    });
    
    console.log('‚úì Whisper module loaded');
    return true;
  } catch(e) {
    console.error('Whisper module error:', e);
    updateUI('error', e.message);
    return false;
  }
}

// ===== INIT VOICE =====
async function initVoice() {
  if (!whisper?.isLoaded() && !(await loadWhisperModule())) return false;
  micPermissionGranted = true;
  updateUI('ready');
  return true;
}

// ===== RECORDING WITH RAW SAMPLES =====
async function startRecording() {
  if (isRecording) return;
  
  try {
    updateUI('loading', 'Accessing microphone...');
    
    currentStream = await navigator.mediaDevices.getUserMedia({ 
      audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true }
    });
    
    micPermissionGranted = true;
    
    audioContext = new AudioContext({ sampleRate: 16000 });
    const source = audioContext.createMediaStreamSource(currentStream);
    
    const processor = audioContext.createScriptProcessor(4096, 1, 1);
    recordedSamples = [];
    
    processor.onaudioprocess = (e) => {
      if (!isRecording) return;
      const input = e.inputBuffer.getChannelData(0);
      recordedSamples.push(new Float32Array(input));
    };
    
    source.connect(processor);
    processor.connect(audioContext.destination);
    
    window._processor = processor;
    
    isRecording = true;
    updateUI('recording');
    
    const analyser = audioContext.createAnalyser();
    source.connect(analyser);
    analyser.fftSize = 64;
    
    $('#waveform').innerHTML = Array(8).fill('<div class="waveform-bar" style="height:20%"></div>').join('');
    const bars = $('#waveform').querySelectorAll('.waveform-bar');
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    
    function updateWaveform() {
      if (!isRecording) return;
      analyser.getByteFrequencyData(dataArray);
      bars.forEach((bar, i) => {
        bar.style.height = Math.max(15, (dataArray[i*2] || 0) / 255 * 100) + '%';
      });
      animationId = requestAnimationFrame(updateWaveform);
    }
    updateWaveform();
    
    console.log('‚úì Recording started');
    
  } catch(e) {
    console.error('Record error:', e);
    if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
      micPermissionGranted = false;
      updateUI('error', 'Microphone access denied');
    } else {
      updateUI('error', 'Failed to record: ' + e.message);
    }
  }
}

async function stopRecording() {
  if (!isRecording) return;
  
  isRecording = false;
  cancelAnimationFrame(animationId);
  currentStream?.getTracks().forEach(t => t.stop());
  window._processor?.disconnect();
  
  if (recordedSamples.length === 0) {
    updateUI('ready');
    return;
  }
  
  updateUI('processing', 'Preparing audio...');
  
  // Merge recorded samples into single Float32Array
  const totalLength = recordedSamples.reduce((acc, arr) => acc + arr.length, 0);
  const merged = new Float32Array(totalLength);
  let offset = 0;
  for (const chunk of recordedSamples) {
    merged.set(chunk, offset);
    offset += chunk.length;
  }
  
  console.log(`Audio: ${merged.length} samples, ${(merged.length/16000).toFixed(1)}s`);
  
  updateUI('processing', 'Running Whisper...');
  
  try {
    // Use WhisperTranscriber module
    const result = await whisper.transcribe(merged);
    
    console.log('Result:', result);
    
    if (result?.text) {
      const text = result.text;
      const current = $('#input').value;
      $('#input').value = current + (current ? ' ' : '') + text;
      autoResize();
      runLint();
      lastInputSource = 'voice';
      console.log(`‚úì Transcribed (${result.language || 'auto'}): ${text} [${result.duration}s]`);
    } else {
      console.log('No speech detected');
    }
    
    updateUI('ready');
    
  } catch(e) {
    console.error('Transcribe error:', e);
    updateUI('error', e.message);
  }
  
  recordedSamples = [];
  audioContext?.close();
  audioContext = null;
}

function cancelRecording() {
  isRecording = false;
  recordedSamples = [];
  cancelAnimationFrame(animationId);
  currentStream?.getTracks().forEach(t => t.stop());
  window._processor?.disconnect();
  audioContext?.close();
  audioContext = null;
  updateUI(whisper?.isLoaded() ? 'ready' : 'idle');
}

// ===== VOICE BUTTON - CLICK TO TOGGLE =====
$('#voiceBtn').onclick = async () => {
  // First click: load Whisper module if needed
  if (!whisper?.isLoaded()) {
    await initVoice();
    return;
  }
  
  // Toggle recording
  if (isRecording) {
    stopRecording();
  } else {
    startRecording();
  }
};

$('#stopBtn').onclick = () => stopRecording();
$('#cancelBtn').onclick = () => cancelRecording();

// ===== OTHER HANDLERS =====
$('#input').onkeydown = e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); send(); } };
$('#input').oninput = () => { 
  autoResize(); 
  debounceLint(); 
  lastInputSource = 'text';
  // Enable/disable send button
  $('#send').disabled = $('#input').value.trim().length === 0;
  
  // Sync with collapsed input
  $('#inputCollapsed').value = $('#input').value;
  $('#sendCollapsed').disabled = $('#input').value.trim().length === 0;
  
  // Show/hide expanded overlay
  updateExpandedState();
  
  // In search mode, send text to parent THEMIS for live filtering
  if (appMode === 'search' && window.parent !== window) {
    window.parent.postMessage({ type: 'search-text', text: $('#input').value }, '*');
  }
};

// Collapsed input handlers
$('#inputCollapsed').oninput = () => {
  const text = $('#inputCollapsed').value;
  $('#input').value = text;
  $('#send').disabled = text.trim().length === 0;
  $('#sendCollapsed').disabled = text.trim().length === 0;
  
  if (text.trim().length > 0) {
    // Show expanded overlay and focus main input
    updateExpandedState();
    $('#input').focus();
    $('#input').selectionStart = $('#input').selectionEnd = text.length;
  }
  
  // Trigger linter
  debounceLint();
  
  // In search mode, send text to parent THEMIS
  if (appMode === 'search' && window.parent !== window) {
    window.parent.postMessage({ type: 'search-text', text: text }, '*');
  }
};

$('#inputCollapsed').onkeydown = e => { 
  if (e.key === 'Enter' && !e.shiftKey) { 
    e.preventDefault(); 
    send(); 
  } 
};

$('#sendCollapsed').onclick = send;
$('#btnModeCollapsed').onclick = () => {
  // Trigger same mode toggle as main button
  $('#btnMode').click();
};

// Function to update expanded state
function updateExpandedState() {
  const hasText = $('#input').value.trim().length > 0;
  const overlay = $('#expandedOverlay');
  const collapsed = $('#collapsedInput');
  
  if (hasText) {
    overlay.classList.add('visible');
    collapsed.classList.add('hidden');
  } else {
    overlay.classList.remove('visible');
    collapsed.classList.remove('hidden');
  }
}

$('#send').onclick = send;
$('#attachBtn').onclick = () => $('#fileInput').click();
$('#fileInput').onchange = e => { addFiles(e.target.files); e.target.value = ''; };
$('#scrollBtn').onclick = () => $('#msgs').scrollTo({ top: $('#msgs').scrollHeight, behavior: 'smooth' });

// ===== MODE TOGGLE - Button shows destination =====
// Analysis mode ‚Üí show S (to go to Search)
// Search mode ‚Üí show A (to go to Analysis)
let appMode = 'analysis';
const modeBtn = $('#btnMode');
modeBtn.innerHTML = '<strong>S</strong>';

// Sync with parent THEMIS mode on load
if (window.parent !== window) {
  try {
    const parentBody = window.parent.document.body;
    if (parentBody.classList.contains('mode-search')) {
      appMode = 'search';
      modeBtn.innerHTML = '<strong>A</strong>';
      $('#btnModeCollapsed').innerHTML = '<strong>A</strong>';
      $('#input').placeholder = 'Search documents...';
      $('#inputCollapsed').placeholder = 'Search documents...';
    }
  } catch(e) { /* cross-origin, ignore */ }
}

$('#btnMode').onclick = () => {
  appMode = appMode === 'analysis' ? 'search' : 'analysis';
  modeBtn.innerHTML = `<strong>${appMode === 'analysis' ? 'S' : 'A'}</strong>`;
  $('#btnModeCollapsed').innerHTML = `<strong>${appMode === 'analysis' ? 'S' : 'A'}</strong>`;
  const placeholder = appMode === 'analysis' ? 'Ask about your documents...' : 'Search documents...';
  $('#input').placeholder = placeholder;
  $('#inputCollapsed').placeholder = placeholder;
  
  // Notify parent THEMIS to toggle mode
  if (window.parent !== window) {
    window.parent.postMessage({ type: 'toggle-mode', mode: appMode }, '*');
  }
};

// ===== DA POPUP (Skills) =====
let daSkills = [];
let daActiveSkill = null;
const daPopup = $('#daPopup');

$('#btnDA').onclick = (e) => {
  e.stopPropagation();
  const isOpen = daPopup.classList.toggle('visible');
  if (isOpen) loadDaSkills();
};

document.addEventListener('click', (e) => {
  // Handle Auto-fix button click
  if (e.target.closest('#linterFixBtn') || e.target.closest('.linter-fix-btn')) {
    console.log('[Chat] Auto-fix clicked via delegation!');
    e.preventDefault();
    e.stopPropagation();
    window.applyFix();
    return;
  }
  
  // Handle DA popup close
  if (!e.target.closest('#daPopup') && !e.target.closest('#btnDA')) {
    daPopup.classList.remove('visible');
  }
  
  // Handle clicks on dynamically created rewrite options
  const rewriteOption = e.target.closest('.rewrite-option');
  if (rewriteOption) {
    console.log('[Chat] Rewrite option clicked via delegation!');
    e.preventDefault();
    e.stopPropagation();
    const template = rewriteOption.dataset.template;
    const skill = rewriteOption.dataset.skill;
    if (template && skill) {
      console.log('[Chat] Rewrite option clicked:', skill);
      window.applyRewrite(template, skill);
    }
  }
});

// Also attach directly to the button element
const fixBtnEl = document.getElementById('linterFixBtn');
if (fixBtnEl) {
  fixBtnEl.onclick = function(e) {
    console.log('[Chat] Auto-fix clicked via onclick!');
    e.preventDefault();
    e.stopPropagation();
    window.applyFix();
    return false;
  };
  fixBtnEl.onmousedown = function(e) {
    console.log('[Chat] Auto-fix MOUSEDOWN detected!');
  };
  console.log('[Chat] Direct onclick handler attached to #linterFixBtn');
} else {
  console.warn('[Chat] #linterFixBtn not found during init');
}

// Debug: log all clicks on document
document.addEventListener('mousedown', function(e) {
  console.log('[Chat] Document mousedown on:', e.target.tagName, e.target.id || e.target.className);
}, true);

// Section toggles
$('#daAssistantsHeader').onclick = () => {
  const body = $('#daAssistantsBody');
  const title = $('#daAssistantsHeader').querySelector('.da-header-title');
  body.classList.toggle('open');
  title.textContent = body.classList.contains('open') ? '‚ñæ ASSISTANTS' : '‚ñ∏ ASSISTANTS';
};
$('#daStyleHeader').onclick = () => {
  const body = $('#daStyleBody');
  const title = $('#daStyleHeader').querySelector('.da-header-title');
  body.classList.toggle('open');
  title.textContent = body.classList.contains('open') ? '‚ñæ STYLE & TONE' : '‚ñ∏ STYLE & TONE';
};
$('#daSystemHeader').onclick = () => {
  const body = $('#daSystemBody');
  const title = $('#daSystemHeader').querySelector('.da-header-title');
  body.classList.toggle('open');
  title.textContent = body.classList.contains('open') ? '‚ñæ SYSTEM' : '‚ñ∏ SYSTEM';
};

async function loadDaSkills() {
  const body = $('#daAssistantsBody');
  body.innerHTML = '<div class="da-empty">Loading...</div>';
  
  try {
    const API = window.LOCALAGENT_API || window.location.origin || 'http://localhost:9998';
    const [availRes, activeRes] = await Promise.all([
      fetch(`${API}/api/skills`).then(r => r.json()).catch(() => ({ skills: [] })),
      fetch(`${API}/api/skills/active`).then(r => r.json()).catch(() => ({ active: [] }))
    ]);
    
    daSkills = availRes.skills || [];
    const activeNames = (activeRes.active || []).map(s => s.name);
    daActiveSkill = activeNames[0] || null;
    
    if (daSkills.length === 0) {
      body.innerHTML = '<div class="da-empty">No skills found<br><small>Add to ~/.localagent/skills/</small></div>';
      updateDaButton();
      return;
    }
    
    body.innerHTML = daSkills.map(skill => {
      const isActive = activeNames.includes(skill.name);
      return `<div class="da-item ${isActive ? 'active' : ''}" data-skill="${skill.name}" data-path="${skill.path || skill.name}">
        <div class="da-item-icon">‚ö°</div>
        <div class="da-item-info">
          <div class="da-item-name">${skill.name}</div>
          <div class="da-item-desc">${skill.description || skill.domain || 'Analysis skill'}</div>
        </div>
        ${isActive ? '<span class="da-item-status">ok</span>' : ''}
      </div>`;
    }).join('');
    
    // Add click handlers
    body.querySelectorAll('.da-item').forEach(item => {
      item.onclick = () => toggleDaSkill(item.dataset.skill, item.dataset.path);
    });
    
    updateDaButton();
  } catch (err) {
    body.innerHTML = '<div class="da-empty">Error loading skills</div>';
    console.error('Skills load error:', err);
  }
}

async function toggleDaSkill(name, path) {
  const API = window.LOCALAGENT_API || window.location.origin || 'http://localhost:9998';
  const isActive = daActiveSkill === name;
  
  try {
    if (isActive) {
      await fetch(`${API}/api/skills/deactivate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ skill_name: name })
      });
      daActiveSkill = null;
    } else {
      if (daActiveSkill) {
        await fetch(`${API}/api/skills/deactivate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ skill_name: daActiveSkill })
        });
      }
      await fetch(`${API}/api/skills/activate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ skill_path: path })
      });
      daActiveSkill = name;
    }
    loadDaSkills();
  } catch (err) {
    console.error('Toggle skill error:', err);
  }
}

function updateDaButton() {
  const btn = $('#btnDA');
  if (daActiveSkill) {
    btn.classList.add('active');
    btn.title = `Active: ${daActiveSkill}`;
  } else {
    btn.classList.remove('active');
    btn.title = 'Assistants & Skills';
  }
}

// ===== FILE COUNTER =====
function updateFileCounter() {
  const counter = $('#fileCounter');
  if (files.length > 0) {
    counter.textContent = files.length;
    counter.classList.add('visible');
  } else {
    counter.classList.remove('visible');
  }
}

function autoResize() {
  const t = $('#input');
  t.style.height = 'auto';
  t.style.height = Math.min(t.scrollHeight, 200) + 'px';
}

document.ondragenter = e => { e.preventDefault(); $('#dropZone').classList.add('active'); };
$('#dropZone').ondragleave = e => { e.preventDefault(); $('#dropZone').classList.remove('active'); };
$('#dropZone').ondragover = e => e.preventDefault();
$('#dropZone').ondrop = e => { e.preventDefault(); $('#dropZone').classList.remove('active'); addFiles(e.dataTransfer.files); };

$('#msgs').onscroll = () => {
  const m = $('#msgs');
  $('#scrollBtn').classList.toggle('visible', m.scrollHeight - m.scrollTop - m.clientHeight > 100);
};

function addFiles(fileList) {
  [...fileList].forEach(f => { if (f.size < 100*1024*1024) files.push(f); });
  renderFiles();
}

function renderFiles() {
  $('#inputFiles').innerHTML = files.map((f,i) => `
    <div class="file">
      <span class="file-icon">${icons.file}</span>
      <span class="file-name" title="${f.name}">${f.name}</span>
      <span class="file-size">${formatSize(f.size)}</span>
      <button class="file-remove" data-i="${i}"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg></button>
    </div>
  `).join('');
  $$('.file-remove').forEach(b => b.onclick = () => { files.splice(b.dataset.i, 1); renderFiles(); });
  updateFileCounter();
}

async function send() {
  const text = $('#input').value.trim();
  if ((!text && !files.length) || generating) return;
  
  $('.empty')?.remove();
  generating = true;
  $('#send').classList.add('stop');
  $('#linterBar').classList.remove('visible');
  $('#linterPreview').classList.remove('visible');
  
  const userFiles = [...files];
  const inputSource = lastInputSource;
  lastInputSource = 'text';
  
  addUserMsg(text, userFiles, inputSource);
  $('#input').value = '';
  $('#inputCollapsed').value = '';
  $('#input').style.height = 'auto';
  files = [];
  renderFiles();
  updateExpandedState(); // Collapse back to single line
  
  const el = addAssistantMsg();
  const content = el.querySelector('.content');
  
  // Create steps container
  const stepsContainer = document.createElement('div');
  stepsContainer.className = 'steps-container';
  stepsContainer.innerHTML = `<div class="steps-header">${icons.chevron}<span>Processing</span><span class="count">...</span></div><div class="steps-body"></div>`;
  el.insertBefore(stepsContainer, el.firstChild);
  
  const stepsHeader = stepsContainer.querySelector('.steps-header');
  const stepsBody = stepsContainer.querySelector('.steps-body');
  const stepsCount = stepsContainer.querySelector('.count');
  stepsHeader.onclick = () => { stepsHeader.classList.toggle('open'); stepsBody.classList.toggle('open'); };
  stepsHeader.classList.add('open');
  stepsBody.classList.add('open');
  
  content.innerHTML = '<span class="cursor"></span>';
  
  try {
    // Call LocalAgent backend API - use same origin as current page
    const API_BASE = window.LOCALAGENT_API || window.location.origin || 'http://localhost:9998';
    
    // Add user message to history
    conversationHistory.push({
      role: 'user',
      content: text
    });
    
    const response = await fetch(`${API_BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        message: text,
        history: conversationHistory.slice(-10), // Send last 10 messages for context
        source: inputSource,
        files: userFiles.map(f => f.name)
      })
    });
    
    const data = await response.json();
    
    // Store context for error correction (Negotiator)
    const messageId = Date.now().toString();
    if (window.setLastLLMContext) {
      window.setLastLLMContext(
        data.response || '',
        text,
        messageId,
        data.skill_used || null,
        data.case_id || null
      );
    }
    
    // Display protocol steps from backend (minimal - user doesn't need to see internals)
    const protocolSteps = data.protocol || data.protocol_steps || [];
    stepsCount.textContent = `${protocolSteps.length} steps`;
    
    // Collapse by default - only expand if user clicks
    stepsHeader.classList.remove('open');
    stepsBody.classList.remove('open');
    
    for (const ps of protocolSteps) {
      const stepEl = addStep(stepsBody, ps.label || ps.step, ps.status === 'complete' ? 'success' : ps.status === 'error' ? 'error' : 'running');
      updateStep(stepEl, ps.status === 'complete' ? 'success' : ps.status === 'error' ? 'error' : 'success');
    }
    
    // Show negotiation info if retries occurred
    if (data.negotiation_attempts && data.negotiation_attempts > 1) {
      const negLabel = data.negotiation_success 
        ? `‚úÖ Response refined (${data.negotiation_attempts} iterations)` 
        : `‚ö†Ô∏è Best effort (${data.negotiation_attempts} attempts)`;
      addStep(stepsBody, negLabel, data.negotiation_success ? 'success' : 'running');
    }
    
    // Get response text
    let responseText = data.response || data.error || 'No response';
    
    // Add assistant response to history
    conversationHistory.push({
      role: 'assistant',
      content: responseText
    });
    
    // Handle tasks output
    if (data.tasks && data.tasks.length > 0) {
      responseText += '\n\n**Tasks executed:**\n';
      for (const task of data.tasks) {
        responseText += `- ${task.id}: ${task.type} ${task.filename || ''}\n`;
      }
    }
    
    // Stream response word by word (without files - those will be added after)
    const words = responseText.split(' ');
    let buffer = '';
    for (const word of words) {
      buffer += word + ' ';
      content.innerHTML = parseContent(buffer) + '<span class="cursor"></span>';
      await delay(10);
    }
    content.innerHTML = parseContent(buffer);
    
    // Debug: log files received
    console.log('Files received from API:', data.files);
    
    // Handle files created - add download buttons
    if (data.files && data.files.length > 0) {
      console.log('Creating file cards for', data.files.length, 'files');
      const filesDiv = document.createElement('div');
      filesDiv.className = 'files';
      filesDiv.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;margin-top:12px;padding-top:12px;border-top:1px solid var(--chat-border)';
      
      for (const file of data.files) {
        const fileUrl = `${API_BASE}${file.url}`;
        const fileCard = document.createElement('a');
        fileCard.href = fileUrl;
        fileCard.download = file.name;
        fileCard.className = 'file-download';
        fileCard.style.cssText = `
          display:flex;align-items:center;gap:8px;padding:10px 14px;
          background:var(--chat-surface);border:1px solid var(--chat-border);
          border-radius:8px;text-decoration:none;color:var(--chat-text);
          transition:all 0.2s;cursor:pointer;
        `;
        fileCard.onmouseover = () => fileCard.style.borderColor = 'var(--chat-accent)';
        fileCard.onmouseout = () => fileCard.style.borderColor = 'var(--chat-border)';
        
        const iconExt = file.type || '.txt';
        const iconColor = {
          '.py': '#3572A5', '.js': '#f1e05a', '.html': '#e34c26',
          '.css': '#563d7c', '.json': '#292929', '.md': '#083fa1'
        }[iconExt] || 'var(--chat-accent)';
        
        fileCard.innerHTML = `
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2">
            <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>
            <path d="M14 2v6h6"/>
          </svg>
          <div style="flex:1">
            <div style="font-weight:500;font-size:13px">${file.name}</div>
            <div style="font-size:11px;color:var(--chat-muted)">${formatSize(file.size || 0)}</div>
          </div>
          <div style="background:var(--chat-accent);color:white;padding:4px 10px;border-radius:6px;font-size:11px;font-weight:500">
            Download
          </div>
        `;
        
        filesDiv.appendChild(fileCard);
      }
      
      content.appendChild(filesDiv);
      
      // Notify parent dashboard to refresh outputs
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({type: 'files-created', files: data.files}, '*');
      }
    }
    
  } catch (e) {
    console.error('Chat error:', e);
    
    // Show error step
    const errorStep = addStep(stepsBody, 'Connection Error', 'error');
    updateStep(errorStep, 'error');
    stepsCount.textContent = '1 step';
    
    // Check if it's a connection error
    if (e.message.includes('Failed to fetch') || e.message.includes('NetworkError')) {
      content.innerHTML = parseContent(`‚ùå **Cannot connect to LocalAgent backend**

Make sure the LocalAgent service is running:

\`\`\`bash
cd ~/localagent_v3
python -m localagent.service.server
\`\`\`

Or start the service:
\`\`\`bash
./START_SERVICE.command
\`\`\`

Backend URL: \`${window.LOCALAGENT_API || window.location.origin || 'http://localhost:9998'}\``);
    } else {
      content.innerHTML = parseContent(`‚ùå **Error:** ${e.message}`);
    }
  }
  
  stepsHeader.classList.remove('open');
  stepsBody.classList.remove('open');
  
  generating = false;
  $('#send').classList.remove('stop');
  $('#msgs').scrollTop = $('#msgs').scrollHeight;
  
  // Return focus to input for continued conversation
  const isExpanded = $('#expandedOverlay').classList.contains('visible');
  if (isExpanded) {
    $('#input').focus();
  } else {
    $('#inputCollapsed').focus();
  }
}

function addStep(container, title, status) {
  const step = document.createElement('div');
  step.className = 'step';
  step.innerHTML = `<div class="step-header"><span class="chevron">${icons.chevron}</span><span class="step-icon ${status}">${icons[status]}</span><span class="step-title">${title}</span><span class="step-time"></span></div><div class="step-content"></div>`;
  container.appendChild(step);
  return step;
}

function updateStep(step, status, duration) {
  step.querySelector('.step-icon').className = 'step-icon ' + status;
  step.querySelector('.step-icon').innerHTML = icons[status];
  if (duration) step.querySelector('.step-time').textContent = (duration/1000).toFixed(2) + 's';
}

// ===== NEGOTIATOR CORRECTION LISTENER =====
// Listen for corrections from the error handler
(function setupNegotiatorListener() {
  let correctionBanner = null;
  
  window.addEventListener('negotiator-correction', function(e) {
    const detail = e.detail;
    
    if (detail.status === 'started') {
      // Show correction banner
      if (!correctionBanner) {
        correctionBanner = document.createElement('div');
        correctionBanner.id = 'correctionBanner';
        correctionBanner.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          padding: 12px 20px;
          background: linear-gradient(90deg, #f59e0b, #d97706);
          color: white;
          font-weight: 600;
          font-size: 13px;
          z-index: 10000;
          display: flex;
          align-items: center;
          gap: 10px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;
        document.body.appendChild(correctionBanner);
      }
      correctionBanner.innerHTML = `
        <span style="animation: pulse 1s infinite">üîÑ</span>
        <span>Negotiator: Correcting error...</span>
        <span style="opacity: 0.8; font-weight: 400; font-size: 12px;">${(detail.error || '').substring(0, 60)}...</span>
      `;
      correctionBanner.style.display = 'flex';
    }
    
    else if (detail.status === 'corrected') {
      // Update banner to success
      if (correctionBanner) {
        correctionBanner.style.background = 'linear-gradient(90deg, #10b981, #059669)';
        correctionBanner.innerHTML = `
          <span>‚úÖ</span>
          <span>Correction applied (attempt ${detail.retry_count})</span>
          <span style="opacity: 0.8; font-weight: 400; font-size: 12px;">Error type: ${detail.error_type}</span>
        `;
        
        // Hide after 3 seconds
        setTimeout(() => {
          if (correctionBanner) {
            correctionBanner.style.display = 'none';
          }
        }, 3000);
      }
      
      // Update the last message in chat with corrected response
      const msgs = document.querySelectorAll('.msg.assistant');
      if (msgs.length > 0) {
        const lastMsg = msgs[msgs.length - 1];
        const content = lastMsg.querySelector('.content');
        if (content && detail.response) {
          // Add correction indicator
          const correctionNote = document.createElement('div');
          correctionNote.style.cssText = `
            margin-top: 12px;
            padding: 10px 14px;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 8px;
            font-size: 12px;
            color: #10b981;
          `;
          correctionNote.innerHTML = `<strong>üîÑ Auto-corrected</strong> (${detail.error_type}) - Attempt ${detail.retry_count}`;
          
          // Replace content with corrected version
          content.innerHTML = parseContent(detail.response);
          content.appendChild(correctionNote);
          
          // Update steps panel if present
          const stepsContainer = lastMsg.querySelector('.steps-container');
          if (stepsContainer && detail.protocol) {
            const stepsBody = stepsContainer.querySelector('.steps-body');
            if (stepsBody) {
              // Add correction steps
              for (const ps of detail.protocol) {
                const stepEl = addStep(stepsBody, ps.label || ps.step, ps.status === 'complete' ? 'success' : ps.status === 'error' ? 'error' : 'running');
                updateStep(stepEl, ps.status === 'complete' ? 'success' : 'error');
              }
              // Expand to show correction steps
              stepsContainer.querySelector('.steps-header').classList.add('open');
              stepsBody.classList.add('open');
            }
          }
        }
      }
    }
    
    else if (detail.status === 'failed') {
      // Update banner to error
      if (correctionBanner) {
        correctionBanner.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)';
        correctionBanner.innerHTML = `
          <span>‚ùå</span>
          <span>Correction failed</span>
          <span style="opacity: 0.8; font-weight: 400; font-size: 12px;">${detail.error || 'Max retries exceeded'}</span>
        `;
        
        // Hide after 5 seconds
        setTimeout(() => {
          if (correctionBanner) {
            correctionBanner.style.display = 'none';
          }
        }, 5000);
      }
    }
  });
  
  // Add pulse animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  `;
  document.head.appendChild(style);
})();

function addUserMsg(text, userFiles, inputSource = 'text') {
  const el = document.createElement('div');
  el.className = 'msg user';
  const filesHtml = userFiles.length ? '<div class="files">' + userFiles.map(f => `<div class="file"><span class="file-icon">${icons.file}</span><span class="file-name">${f.name}</span></div>`).join('') + '</div>' : '';
  const sourceIcon = inputSource === 'voice' ? ' üé§' : '';
  el.innerHTML = `<div class="bubble"><div class="content">${esc(text)}</div>${filesHtml}<div class="meta">${time()}${sourceIcon}</div></div>`;
  $('#msgs').appendChild(el);
  $('#msgs').scrollTop = $('#msgs').scrollHeight;
}

function addAssistantMsg() {
  const el = document.createElement('div');
  el.className = 'msg assistant';
  el.innerHTML = `<div class="bubble"><div class="content"><span class="cursor"></span></div><div class="meta">${time()}</div></div>`;
  $('#msgs').appendChild(el);
  return el;
}

function parseContent(s) {
  s = s.replace(/```(\w+)?\n([\s\S]*?)```/g, (_, l, c) => `<div class="code-block"><header><span>${l||'code'}</span></header><pre>${esc(c)}</pre></div>`);
  s = s.replace(/`([^`]+)`/g, '<code>$1</code>');
  s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  return s;
}

// Initialize skill on load
(async function() {
  if (window.PromptLinter && window.PromptLinter.loadActiveSkill) {
    const skill = await window.PromptLinter.loadActiveSkill();
    if (skill) {
      console.log('[Chat] Active skill:', skill.name);
      $('#linterTask').textContent = 'üéØ ' + skill.name;
    }
  }
})();
</script>
</body>
</html>
